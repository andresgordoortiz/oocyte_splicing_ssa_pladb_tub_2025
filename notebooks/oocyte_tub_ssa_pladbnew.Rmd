---
title: "Oocyte Alternative Splicing Analysis"
subtitle: "Tubercidin, Spliceostatin A & Pladienolide B"
author: "Andrés Gordo Ortiz @Al Jord Lab CRG"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: flatly
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    code_folding: hide
    code_download: false
    df_print: paged
    number_sections: true

editor_options:
  markdown:
    wrap: 72

header-includes:
  - '<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">'
  - '<style>
        /* Base styling */
        body {
          font-family: "Roboto", sans-serif;
          color: #333;
          background-color: #ffffff;
          margin: 0;
          padding: 20px;
        }
        .container {
          max-width: 960px;
          margin: auto;
        }

        /* Headings */
        h1, h2, h3, h4, h5, h6 {
          color: #2C3E50;
          text-align: center;
          font-weight: 700;
          margin: 0.5em 0;
        }
        h1 { font-size: 2.5em; }
        h2 { font-size: 2em; }
        h3 { font-size: 1.75em; }

        /* Text styling */
        p {
          line-height: 1.6;
          margin-bottom: 1em;
          text-align: justify;
        }
        .subtitle, .author, .date {
          text-align: center;
          color: #2C3E50;
          margin-bottom: 0.5em;
        }

        /* Links */
        a {
          color: #0275d8;
          text-decoration: none;
        }
        a:hover {
          text-decoration: underline;
        }

        /* Tables */
        table {
          width: 100%;
          border-collapse: collapse;
          margin: 20px 0;
        }
        th, td {
          border: 1px solid #ddd;
          padding: 10px;
        }
        th {
          background-color: #2C3E50;
          color: #fff;
        }
        tr:nth-child(even) {
          background-color: #f9f9f9;
        }
        tr:hover {
          background-color: #f1f1f1;
        }
     </style>'
---




```{r setup, include=FALSE}
# Ensure a clean environment and load required libraries.
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)


# Load required libraries
library("betAS")
library("ggplot2")
library("plotly")
library("dplyr")
library("tidyverse")
library("cowplot")
library("DT")
library("paletteer")
library("ggupset")
library("showtext")
library("ggtext")
library("readxl")
library("biomaRt")
library("patchwork")
library("org.Mm.eg.db")
library("org.Hs.eg.db")
library("enrichplot")
library("DOSE")
library("clusterProfiler")
library("ComplexHeatmap")
library("enrichR")
library("colorRamp2")
library("dendextend")
library("UpSetR")
library("svglite")

# Register Google fonts
showtext_auto()
font_add_google("Roboto", "roboto")
font="roboto"

```

# Introduction to this Analysis

## Part 1: Upstream Analysis

The upstream analysis is performed on the CRG cluster using the Bash command line. This phase involves:

1. **Alignment**:
   - Aligning the sequences to the latest mouse genome release (mm10) using **Bowtie2** through the [Vast-Tools align function](https://link.springer.com/protocol/10.1007/978-1-0716-2521-7_7).

2. **Event Detection**:
   - Importing inclusion tables generated by Vast-Tools into RStudio. Vast-Tools does **not** find new splicing events, relaying on a manually curated database, [VASTDB](https://vastdb.crg.eu/), with more than 600.000 splicing events. The end result is an `Inclusion_table.tab`, which contains the splicing events as rows and the samples as columns. Splicing is quantified using the Percentage Spliced-In (PSI) parameter, which shows the percentage at which a given splicing event occurs across all sequencing reads of the gene. The database covers the following splicing events:

     - **Exons (EX)**: Cassette sequences that are either included or excluded in the mature mRNA.
     - **Introns (IN)**: Introns that are either retained or spliced out in the mature mRNA.
     - **Alternative 5' Splice Sites (Alt5)**: Exons that are spliced at different 5' sites (donor sites).
     - **Alternative 3' Splice Sites (Alt3)**: Exons that are spliced at different 3' sites (acceptor sites).
     - **Microexons (MIC)**: Exons that are shorter than 27 nucleotides.

---

## Part 2: Statistical Analysis


1. **Statistical Testing**:
   - Use the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) in R to perform Beta Distribution simulations to obtain:
     - **False Discovery Rate (FDR)**
     - **delta Percentage Spliced-in (dPSI)**

2. **Filtering Criteria**: Significant events are defined by
     - FDR <= 0.05
     - |dPSI| >= 0.1 (out of 1. That is, at least a 10% increase or decrease in PSI)

All the code history can be accessed through its [GitHub Repository](https://github.com/andresgordoortiz/24crg_adel_manu_oocyte_splicing)

---


```{r inclusion tables}

splicing_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/new_data_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")

pladb_data<-splicing_data[,1:18]
ssa_tub_data<-splicing_data[, c(1:6, 19:36)]

pladb_events <- filterEvents(getEvents(pladb_data, tool = "vast-tools"), N = 10)
ssa_tub_events <- filterEvents(getEvents(ssa_tub_data, tool = "vast-tools"), N = 10)


exons_pladb <- filterEvents(pladb_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 10)
introns_pladb <- filterEvents(pladb_events, types = c("IR"), N = 10)
alt_pladb <- filterEvents(pladb_events, types = c("Alt5", "Alt3"), N = 10)

exons_ssa_tub <- filterEvents(ssa_tub_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 10)
introns_ssa_tub <- filterEvents(ssa_tub_events, types = c("IR"), N = 10)
alt_ssa_tub <- filterEvents(ssa_tub_events, types = c("Alt5", "Alt3"), N = 10)


```


## Metadata { .tabset}

### PladB

```{r metadata pladb}
# Load metadata file containing sample information
metadata_pladb<-data.frame(samples=colnames(pladb_events$PSI)[7:12],condition=rep(c("control_pladb","pladb_3mm"), each=3))
DT::datatable(metadata_pladb, options = list(pageLength = nrow(metadata_pladb), scrollX = TRUE))
```

### Spliceostatin A & Tuberdicin

```{r metadata ssa tub}
# Load metadata file containing sample information
metadata_ssa_tub<-data.frame(samples=colnames(ssa_tub_events$PSI)[7:15],condition=rep(c("control","tub_10mm","ssa_1mm"), each=3))
DT::datatable(metadata_ssa_tub, options = list(pageLength = nrow(metadata_ssa_tub), scrollX = TRUE))
```

---

# Total Splicing Events

This plot shows the total number of splicing events found during the **mapping** having at least **10** supporting reads across samples, alongside the proportions of each type of event. It is important to know that *vast-tools* does not find new events, but it identifies those manually curated in the database. The total number is the same for all datasets, as it is the total number of events registered and curated in ***VASTDB***.


```{r splicing events barplot stacked, fig.width=10, fig.height=6}

# Adjusted version of the script
splicing_events_df <- tibble(
  event_type = names(pladb_events$EventsPerType),
  pladb = pladb_events$EventsPerType,
  ssa_tub = ssa_tub_events$EventsPerType
)

splicing_events_long <- splicing_events_df %>%
  pivot_longer(cols = c(pladb,ssa_tub),
               names_to = "study", values_to = "count") %>%
  mutate(event_type = ifelse(event_type %in% c("C1", "C2", "C3", "ANN", "S", "MIC"), "EX", event_type)) %>%
  group_by(study, event_type) %>%
  summarize(count = sum(count, na.rm = TRUE), .groups = "drop")

# Proportion bar plot
plot_proportion <- ggplot(splicing_events_long, aes(fill = event_type, y = count, x = study)) +
  geom_bar(position = "fill", stat = "identity") +
  labs(
    title = "Proportion of Splicing Events by Study",
    x = NULL,
    y = "Proportion of Events",
    fill = "Event Type"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    plot.title = element_markdown(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5)
  ) +
  scale_fill_paletteer_d("MetBrewer::Hokusai3")

splicing_events_long_sum<-splicing_events_long %>%
  dplyr::group_by(study) %>%
  summarize(count = sum(count))


# Absolute counts plot
plot_absolute <- ggplot(splicing_events_long_sum, aes(y = count, x = study)) +
  geom_point(color = "#C70039", size = 3) +
  geom_text(aes(label = count), vjust = -1, size = 4, check_overlap = TRUE) +
  labs(
    x = "Study",
    y = "Number of Events",
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text( size=15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3)
  ) +
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.2)))


# Combine plots
combined_plot <- plot_proportion / plot_absolute +
  plot_layout(heights = c(1, 0.5)) &
  theme(plot.margin = margin(5,5, 0, 5))

ggsave("events_mapped.svg", plot = combined_plot, width = 10, height = 6, units = "in", dpi = 300)

# Display combined plot
combined_plot
```

```{r general stats}


exons_per_gene<-read.table("coding_unique_exon_counts_per_gene.txt")
colnames(exons_per_gene)<-c("gene","exons")
```

# Inclusion or Exclusion Plots { .tabset}

These plots show the distribution of the splicing change (dPSI) comparing each drug vs the control. If there is a tendency towards inclusion or exclusion, the bell-shaped curve will be shifted to the right or left, respectively. First, I calculated the mean of each event per condition and then I calculated the difference between means for each event. The subtitle shows the Wilcoxon test assessing this possible asymmetry. The area under the curve for both sides (>0 and <0) is shown numerically. Only events with a dPSI greater or lower than 0 are shown for clarity.

## Exons

### Tubercidin

```{r inclusionumber of exons tub, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------
# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
tub_exons_df <- exons_ssa_tub$PSI %>%
  filter(complete.cases(select(., 7:12)))

# Compute the averages and PSI difference for each row
tub_exons_df <- tub_exons_df %>%
  mutate(
    avg_control = rowMeans(select(., 7:9)),
    avg_tub = rowMeans(select(., 10:12)),
    difference = avg_tub - avg_control
  ) %>%
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(tub_exons_df) > 5000) {
  shapiro_sample <- sample(tub_exons_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(tub_exons_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(tub_exons_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(tub_exons_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(tub_exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(tub_exons_df$difference > 0) * 100, 1)
n_samples <- nrow(tub_exons_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  tub_exons_df[abs(tub_exons_df$difference) > 0, ],
  aes(x = difference)
) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0),
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Exons in Tubercidin",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (Tub 10mm - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Assign colors explicitly to match annotations
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 5, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 5, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/tub_exons_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)


```

This next plot shows if there is any tendency towards exclusion or inclusion as the number of exons of that gene increases. The results is that none of the drigs causes a selective inclusion patterns depending on the gene complexity (number of exons).

```{r skewness tub}

ensembl <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

# Retrieve gene symbols
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters = "mgi_symbol",
  values = tub_exons_df$GENE,
  mart = ensembl
)

# Merge gene symbols and exon counts
tub_exons_df <- tub_exons_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id), by = c("GENE" = "mgi_symbol")) %>%
  left_join(exons_per_gene %>% select(gene, exons), by = c("ensembl_gene_id" = "gene")) %>%
  rename(numb_exons = exons)


library(dplyr)
library(ggplot2)
library(purrr)

set.seed(123)

# 1. Manual skewness
skewness_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

# 2. Bin the data
binned <- tub_exons_df %>%
  filter(abs(difference) > 0, !is.na(numb_exons)) %>%
  mutate(
    exon_bin = cut(numb_exons,
                   breaks = c(0, 10, 50, Inf),
                   labels = c("1–10", "11–50", "51+"),
                   right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Bootstrap skewness per bin
boot_results <- binned %>%
  group_by(exon_bin) %>%
  summarise(
    boot_skews = list(replicate(
      1000,
      skewness_manual(sample(difference, replace = TRUE))
    )),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )


library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)

font_add_google(name = "Courier Prime", family = "Courier Prime")
library(showtext)
showtext_auto()

boot_long <- boot_results %>%
  mutate(exon_bin = factor(exon_bin,
                           levels = c("1–10", "11–50", "51+"))) %>%
  unnest(boot_skews)

p <- ggplot(boot_results,
            aes(x = exon_bin, y = skew_estimate)) +

  # jittered bootstraps
  geom_jitter(data = boot_long,
              aes(fill = exon_bin, y = boot_skews),
              position = position_jitter(width = 0.15, height = 0),
              shape = 21,
              color = "gray30",
              size = 2,
              alpha = 0.05,
              stroke = 0.8) +

  # polynomial regression (2nd degree)
  geom_smooth(data = boot_long,
              aes(x = as.numeric(exon_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x, 2),
              se = FALSE,
              linetype = "dashed",
              color = "grey40",    # grey line
              size = 1.5) +        # thicker

  # main points
  geom_point(aes(fill = exon_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +

  scale_fill_manual(values = c(
    "1–10"  = "#d1cbe5",
    "11–50" = "#9671bd",
    "51+"   = "#6a408d"
  ), name = "Exon Bin",
     guide = guide_legend(override.aes = list(shape = 21,
                                             alpha = 1,
                                             size = 4,
                                             color = "gray30"))) +


  # significance aesthetics
  scale_color_manual(values = c(`TRUE`  = "#378d94",
                                `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +

  # densify grid on y-axis
  scale_y_continuous(
    breaks = pretty_breaks(n = 5),         # fewer major
    minor_breaks = waiver(),               # you can specify seq(min, max, length.out) here
    expand = expansion(add = 0.1)
  ) +

  # densify grid on x-axis
  scale_x_discrete(expand = expansion(add = 0.5)) +

  # labels
  labs(
    title = "Bootstrapped Skewness of Tuberdicin Splicing",
    x     = "Number of exons per gene",
    y     = "Skewness of ΔPSI Distribution"
  ) +

  # theme tweaks
  # theme tweaks
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",

    # Remove grid lines, but keep the square
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),

    # add a border around the panel
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),

    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10),
  ) +

  # Add a grey line at y = 0
  geom_hline(yintercept = 0, color = "grey50", linetype = "solid", size = 0.5)

print(p)


ggsave("tub_exons.svg",
       width  = 6,
       height = 6)

```

### PladB

```{r inclusionumber of exons pladb, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------

# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
pladb_exons_df <- exons_pladb$PSI %>%
  filter(complete.cases(select(., 7:12)))

# Compute the averages and PSI difference for each row
pladb_exons_df <- pladb_exons_df %>%
  mutate(
    avg_pladb = rowMeans(select(., 10:12)),
    avg_control = rowMeans(select(., 7:9)),
    difference = avg_pladb - avg_control
  ) %>%
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(pladb_exons_df) > 5000) {
  shapiro_sample <- sample(pladb_exons_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(pladb_exons_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(pladb_exons_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(pladb_exons_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(pladb_exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(pladb_exons_df$difference > 0) * 100, 1)
n_samples <- nrow(pladb_exons_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(pladb_exons_df, aes(x = difference)) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0),
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Exons in Pladienolide B",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (PladB 3mm - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = seq(-100, 100, by = 25)
  ) +
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),  # Blue for dPSI < 0, Red for dPSI > 0
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  annotate("label", x = -65, y = 0.1, hjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 7, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/pladb_exons_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)
print(plot_psi_distribution)


```


```{r skewness pladb}


# Retrieve gene symbols
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters = "mgi_symbol",
  values = pladb_exons_df$GENE,
  mart = ensembl
)

# Merge gene symbols and exon counts
pladb_exons_df <- pladb_exons_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id), by = c("GENE" = "mgi_symbol")) %>%
  left_join(exons_per_gene %>% select(gene, exons), by = c("ensembl_gene_id" = "gene")) %>%
  rename(numb_exons = exons)


library(dplyr)
library(ggplot2)
library(purrr)

set.seed(123)

# 1. Manual skewness
skewness_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

# 2. Bin the data
binned <- pladb_exons_df %>%
  filter(abs(difference) > 0, !is.na(numb_exons)) %>%
  mutate(
    exon_bin = cut(numb_exons,
                   breaks = c(0, 10, 50, Inf),
                   labels = c("1–10", "11–50", "51+"),
                   right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Bootstrap skewness per bin
boot_results <- binned %>%
  group_by(exon_bin) %>%
  summarise(
    boot_skews = list(replicate(
      1000,
      skewness_manual(sample(difference, replace = TRUE))
    )),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )


library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)

font_add_google(name = "Courier Prime", family = "Courier Prime")
library(showtext)
showtext_auto()

boot_long <- boot_results %>%
  mutate(exon_bin = factor(exon_bin,
                           levels = c("1–10", "11–50", "51+"))) %>%
  unnest(boot_skews)

p <- ggplot(boot_results,
            aes(x = exon_bin, y = skew_estimate)) +

  # jittered bootstraps
  geom_jitter(data = boot_long,
              aes(fill = exon_bin, y = boot_skews),
              position = position_jitter(width = 0.15, height = 0),
              shape = 21,
              color = "gray30",
              size = 2,
              alpha = 0.05,
              stroke = 0.8) +

  # polynomial regression (2nd degree)
  geom_smooth(data = boot_long,
              aes(x = as.numeric(exon_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x, 2),
              se = FALSE,
              linetype = "dashed",
              color = "grey40",    # grey line
              size = 1.5) +        # thicker

  # main points
  geom_point(aes(fill = exon_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +

  scale_fill_manual(values = c(
    "1–10"  = "#d1cbe5",
    "11–50" = "#9671bd",
    "51+"   = "#6a408d"
  ), name = "Exon Bin",
     guide = guide_legend(override.aes = list(shape = 21,
                                             alpha = 1,
                                             size = 4,
                                             color = "gray30"))) +


  # significance aesthetics
  scale_color_manual(values = c(`TRUE`  = "#378d94",
                                `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +

  # densify grid on y-axis
  scale_y_continuous(
    breaks = pretty_breaks(n = 5),         # fewer major
    minor_breaks = waiver(),               # you can specify seq(min, max, length.out) here
    expand = expansion(add = 0.1)
  ) +

  # densify grid on x-axis
  scale_x_discrete(expand = expansion(add = 0.5)) +

  # labels
  labs(
    title = "Bootstrapped Skewness of Pladienolide B Splicing",
    x     = "Number of exons per gene",
    y     = "Skewness of ΔPSI Distribution"
  ) +

  # theme tweaks
  # theme tweaks
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",

    # Remove grid lines, but keep the square
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),

    # add a border around the panel
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),

    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10),
  ) +

  # Add a grey line at y = 0
  geom_hline(yintercept = 0, color = "grey50", linetype = "solid", size = 0.5)

print(p)


ggsave("pladb_exons.svg",
       width  = 6,
       height = 6)

```

### Spliceostatin A

```{r inclusionumber of exons ssa, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------

# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
ssa_exons_df <- exons_ssa_tub$PSI %>%
  filter(complete.cases(select(., 7:15)))

# Compute the averages and PSI difference for each row
ssa_exons_df <- ssa_exons_df %>%
  mutate(
    avg_ssa = rowMeans(select(., 13:15)),
    avg_control = rowMeans(select(., 7:9)),
    difference = avg_ssa - avg_control
  ) %>%
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(ssa_exons_df) > 5000) {
  shapiro_sample <- sample(ssa_exons_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(ssa_exons_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(ssa_exons_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(ssa_exons_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(ssa_exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(ssa_exons_df$difference > 0) * 100, 1)
n_samples <- nrow(ssa_exons_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(ssa_exons_df, aes(x = difference)) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0),
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Exons in Spliceostatin A",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (Spliceostatin A 1mm - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = seq(-100, 100, by = 25)
  ) +
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),  # Blue for dPSI < 0, Red for dPSI > 0
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  annotate("label", x = -65, y = 0.1, hjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 7, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/ssa_exons_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)
print(plot_psi_distribution)


```

```{r skewness ssa}


# Retrieve gene symbols
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters = "mgi_symbol",
  values = ssa_exons_df$GENE,
  mart = ensembl
)

# Merge gene symbols and exon counts
ssa_exons_df <- ssa_exons_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id), by = c("GENE" = "mgi_symbol")) %>%
  left_join(exons_per_gene %>% select(gene, exons), by = c("ensembl_gene_id" = "gene")) %>%
  rename(numb_exons = exons)


library(dplyr)
library(ggplot2)
library(purrr)

set.seed(123)

# 1. Manual skewness
skewness_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

# 2. Bin the data
binned <- ssa_exons_df %>%
  filter(abs(difference) > 0, !is.na(numb_exons)) %>%
  mutate(
    exon_bin = cut(numb_exons,
                   breaks = c(0, 10, 50, Inf),
                   labels = c("1–10", "11–50", "51+"),
                   right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Bootstrap skewness per bin
boot_results <- binned %>%
  group_by(exon_bin) %>%
  summarise(
    boot_skews = list(replicate(
      1000,
      skewness_manual(sample(difference, replace = TRUE))
    )),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )


library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)

font_add_google(name = "Courier Prime", family = "Courier Prime")
library(showtext)
showtext_auto()

boot_long <- boot_results %>%
  mutate(exon_bin = factor(exon_bin,
                           levels = c("1–10", "11–50", "51+"))) %>%
  unnest(boot_skews)

p <- ggplot(boot_results,
            aes(x = exon_bin, y = skew_estimate)) +

  # jittered bootstraps
  geom_jitter(data = boot_long,
              aes(fill = exon_bin, y = boot_skews),
              position = position_jitter(width = 0.15, height = 0),
              shape = 21,
              color = "gray30",
              size = 2,
              alpha = 0.05,
              stroke = 0.8) +

  # polynomial regression (2nd degree)
  geom_smooth(data = boot_long,
              aes(x = as.numeric(exon_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x, 2),
              se = FALSE,
              linetype = "dashed",
              color = "grey40",    # grey line
              size = 1.5) +        # thicker

  # main points
  geom_point(aes(fill = exon_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +

  scale_fill_manual(values = c(
    "1–10"  = "#d1cbe5",
    "11–50" = "#9671bd",
    "51+"   = "#6a408d"
  ), name = "Exon Bin",
     guide = guide_legend(override.aes = list(shape = 21,
                                             alpha = 1,
                                             size = 4,
                                             color = "gray30"))) +


  # significance aesthetics
  scale_color_manual(values = c(`TRUE`  = "#378d94",
                                `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +

  # densify grid on y-axis
  scale_y_continuous(
    breaks = pretty_breaks(n = 5),         # fewer major
    minor_breaks = waiver(),               # you can specify seq(min, max, length.out) here
    expand = expansion(add = 0.1)
  ) +

  # densify grid on x-axis
  scale_x_discrete(expand = expansion(add = 0.5)) +

  # labels
  labs(
    title = "Bootstrapped Skewness of Spliceostatin A Splicing",
    x     = "Number of exons per gene",
    y     = "Skewness of ΔPSI Distribution"
  ) +

  # theme tweaks
  # theme tweaks
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",

    # Remove grid lines, but keep the square
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),

    # add a border around the panel
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),

    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10),
  ) +

  # Add a grey line at y = 0
  geom_hline(yintercept = 0, color = "grey50", linetype = "solid", size = 0.5)

print(p)


ggsave("ssa_exons.svg",
       width  = 6,
       height = 6)

```

## Introns

### Tubercidin

```{r inclusionumber of introns tub, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------
# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
tub_introns_df <- introns_ssa_tub$PSI %>%
  filter(complete.cases(select(., 7:12)))

# Compute the averages and PSI difference for each row
tub_introns_df <- tub_introns_df %>%
  mutate(
    avg_control = rowMeans(select(., 7:9)),
    avg_tub = rowMeans(select(., 10:12)),
    difference = avg_tub - avg_control
  ) %>%
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(tub_introns_df) > 5000) {
  shapiro_sample <- sample(tub_introns_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(tub_introns_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(tub_introns_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(tub_introns_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(tub_introns_df$difference < 0) * 100, 1)
pct_above <- round(mean(tub_introns_df$difference > 0) * 100, 1)
n_samples <- nrow(tub_introns_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  tub_introns_df[abs(tub_introns_df$difference) > 0, ],
  aes(x = difference)
) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0),
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Introns in Tubercidin",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (Tub 10mm - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Assign colors explicitly to match annotations
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 5, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 5, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/tub_introns_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)


```



### PladB

```{r inclusionumber of introns pladb, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------

# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
pladb_introns_df <- introns_pladb$PSI %>%
  filter(complete.cases(select(., 7:12)))

# Compute the averages and PSI difference for each row
pladb_introns_df <- pladb_introns_df %>%
  mutate(
    avg_pladb = rowMeans(select(., 10:12)),
    avg_control = rowMeans(select(., 7:9)),
    difference = avg_pladb - avg_control
  ) %>%
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(pladb_introns_df) > 5000) {
  shapiro_sample <- sample(pladb_introns_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(pladb_introns_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(pladb_introns_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(pladb_introns_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(pladb_introns_df$difference < 0) * 100, 1)
pct_above <- round(mean(pladb_introns_df$difference > 0) * 100, 1)
n_samples <- nrow(pladb_introns_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(pladb_introns_df, aes(x = difference)) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0),
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Introns in Pladienolide B",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (PladB 3mm - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = seq(-100, 100, by = 25)
  ) +
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),  # Blue for dPSI < 0, Red for dPSI > 0
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  annotate("label", x = -65, y = 0.1, hjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 7, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/pladb_introns_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)
print(plot_psi_distribution)


```

### Spliceostatin A

```{r inclusionumber of introns ssa, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------

# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
ssa_introns_df <- introns_ssa_tub$PSI %>%
  filter(complete.cases(select(., 7:15)))

# Compute the averages and PSI difference for each row
ssa_introns_df <- ssa_introns_df %>%
  mutate(
    avg_ssa = rowMeans(select(., 13:15)),
    avg_control = rowMeans(select(., 7:9)),
    difference = avg_ssa - avg_control
  ) %>%
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(ssa_introns_df) > 5000) {
  shapiro_sample <- sample(ssa_introns_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(ssa_introns_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(ssa_introns_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(ssa_introns_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(ssa_introns_df$difference < 0) * 100, 1)
pct_above <- round(mean(ssa_introns_df$difference > 0) * 100, 1)
n_samples <- nrow(ssa_introns_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(ssa_introns_df, aes(x = difference)) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0),
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Introns in Spliceostatin A",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (Spliceostatin A 1mm - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = seq(-100, 100, by = 25)
  ) +
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),  # Blue for dPSI < 0, Red for dPSI > 0
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  annotate("label", x = -65, y = 0.1, hjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 7, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/ssa_introns_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)
print(plot_psi_distribution)


```


# PCA Plot { .tabset}


## PladB

```{r pca calculation pladb}
# Subset and scale data
pca_splicing <- pladb_events$PSI[, c("EVENT",pladb_events$Samples)] %>%
  na.omit()

rownames(pca_splicing)<- pca_splicing$EVENT
pca_splicing<-t(pca_splicing[,-1])


pca_result <- prcomp(pca_splicing)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-metadata_pladb$condition
```

```{r pca plotting pladb}
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition))) +
  geom_point(size = 6, alpha = 0.9) +
  labs(
    title = "<b style='font-size:18px;'>PCA of Samples (PSI Data)</b>",
    x = paste("PC1 (", round(100 * summary(pca_result)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result)$importance[2, 2], 1), "%)", sep = ""),
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    plot.title = element_markdown(),
    plot.title.position = "plot",
    axis.title = element_text(size = 14, margin = margin(t = 10)),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  scale_color_paletteer_d("MetBrewer::Hokusai3") +
  coord_fixed()
ggsave("final_plots/pca_pladb.svg", pca_plot, width = 5, height = 5, dpi = 300)


pca_plot

```

## Spliceostatin & Tubercidin

```{r pca calculation ssa tub}
# Subset and scale data
pca_splicing <- ssa_tub_events$PSI[, c("EVENT",ssa_tub_events$Samples)] %>%
  na.omit()

rownames(pca_splicing)<- pca_splicing$EVENT
pca_splicing<-t(pca_splicing[,-1])


pca_result <- prcomp(pca_splicing)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-metadata_ssa_tub$condition
```

```{r pca plotting ssa tub}
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition))) +
  geom_point(size = 6, alpha = 0.9) +
  labs(
    title = "<b style='font-size:18px;'>PCA of Samples (PSI Data)</b>",
    x = paste("PC1 (", round(100 * summary(pca_result)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result)$importance[2, 2], 1), "%)", sep = ""),
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    plot.title = element_markdown(),
    plot.title.position = "plot",
    axis.title = element_text(size = 14, margin = margin(t = 10)),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  scale_color_paletteer_d("MetBrewer::Hokusai3") +
  coord_fixed()
ggsave("final_plots/pca_ssa_tub.svg", pca_plot, width = 5, height = 5, dpi = 300)


pca_plot

```



# Exon Lists

```{r aux_featuregroup}
# Extract unique groups and sample IDs

# Pladb

groups<- unique(metadata_pladb[, "condition"])
samples <- metadata_pladb$samples


random_colors=c("#D8D97AFF", "#95C36EFF", "#74C8C3FF", "#5A97C1FF", "#295384FF", "#0A2E57FF")


# Create group list with metadata
groupList <- lapply(1:length(groups), function(i) {
  list(
    name = groups[i],
    samples = samples[metadata_pladb[, "condition"] == groups[i]],
    color = random_colors[i]
  )
})
names(groupList) <- groups


group_controlpladb<-"control_pladb"
group_control<-"control"
group_pladB<-"pladb_3mm"
group_tub<-"tub_10mm"
group_ssa<-"ssa_1mm"


samples_controlpladb <- groupList[[group_controlpladb]]$samples
#samples_control <- groupList[[group_control]]$samples
samples_pladb <- groupList[[group_pladB]]$samples
#samples_tub <- groupList[[group_tub]]$samples
#samples_ssa <- groupList[[group_ssa]]$samples

colsGroup_controlpladb <- convertCols(pladb_events$PSI, samples_controlpladb)
#colsGroup_control <- convertCols(splicing_events$PSI, samples_control)
colsGroup_pladb <- convertCols(pladb_events$PSI, samples_pladb)
#colsGroup_tub<- convertCols(splicing_events$PSI, samples_tub)
#colsGroup_ssa <- convertCols(splicing_events$PSI, samples_ssa)


# ssa tub

groups<- unique(metadata_ssa_tub[, "condition"])
samples <- metadata_ssa_tub$samples


random_colors=c("#D8D97AFF", "#95C36EFF", "#74C8C3FF", "#5A97C1FF", "#295384FF", "#0A2E57FF")


# Create group list with metadata
groupList <- lapply(1:length(groups), function(i) {
  list(
    name = groups[i],
    samples = samples[metadata_ssa_tub[, "condition"] == groups[i]],
    color = random_colors[i]
  )
})
names(groupList) <- groups



#samples_controlpladb <- groupList[[group_controlpladb]]$samples
samples_control <- groupList[[group_control]]$samples
#samples_pladb <- groupList[[group_pladB]]$samples
samples_tub <- groupList[[group_tub]]$samples
samples_ssa <- groupList[[group_ssa]]$samples

#colsGroup_controlpladb <- convertCols(splicing_events$PSI, samples_controlpladb)
colsGroup_control <- convertCols(ssa_tub_events$PSI, samples_control)
#colsGroup_pladb <- convertCols(splicing_events$PSI, samples_pladb)
colsGroup_tub<- convertCols(ssa_tub_events$PSI, samples_tub)
colsGroup_ssa <- convertCols(ssa_tub_events$PSI, samples_ssa)

```

## Calculations

```{r pdiff calculations}
set.seed(42) #Setting seed for downstream simulations of the beta distribution

# Prepare table for fmn2dko
tub_fdr_df <- prepareTableVolcanoFDR(
  psitable = ssa_tub_events$PSI,
  qualtable = ssa_tub_events$Qual,
  npoints = 500,
  colsA = colsGroup_control,
  colsB = colsGroup_tub,
  labA = colsGroup_control,
  labB = colsGroup_tub,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

pladb_fdr_df <- prepareTableVolcanoFDR(
  psitable = pladb_events$PSI,
  qualtable = pladb_events$Qual,
  npoints = 500,
  colsA = colsGroup_controlpladb,
  colsB = colsGroup_pladb,
  labA = colsGroup_controlpladb,
  labB = colsGroup_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

ssa_fdr_df <- prepareTableVolcanoFDR(
  psitable = ssa_tub_events$PSI,
  qualtable = ssa_tub_events$Qual,
  npoints = 500,
  colsA = colsGroup_control,
  colsB = colsGroup_ssa,
  labA = colsGroup_control,
  labB = colsGroup_ssa,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)


write.csv(tub_fdr_df,"tub_fdr.csv")
write.csv(pladb_fdr_df,"pladb_fdr.csv")
write.csv(ssa_fdr_df,"ssa_fdr.csv")



differential_tub<-na.omit(tub_fdr_df[tub_fdr_df$FDR <= 0.05 & abs(tub_fdr_df$deltapsi) >= 0.1,])

differential_pladb<-na.omit(pladb_fdr_df[pladb_fdr_df$FDR <= 0.05 & abs(pladb_fdr_df$deltapsi) >= 0.1,])

differential_ssa<-na.omit(ssa_fdr_df[ssa_fdr_df$FDR <= 0.05 & abs(ssa_fdr_df$deltapsi) >= 0.1,])

```




## Volcano Plots { .tabset}


### Tuberdicine

```{r tub fdr volcano exons}
tub_exons<-tub_fdr_df[grepl("EX",tub_fdr_df$EVENT),]

differential_tub_exons<-differential_tub[grepl("EX",differential_tub$EVENT),]
differential_pladb_exons<-differential_pladb[grepl("EX",differential_pladb$EVENT),]
differential_ssa_exons<-differential_ssa[grepl("EX",differential_ssa$EVENT),]


shared_exons<-intersect(differential_tub_exons$EVENT, differential_pladb_exons$EVENT)
shared_exons<-intersect(shared_exons, differential_ssa_exons$EVENT)

library(ggrepel)
# Add a Shared column based on the shared_exons
tub_exons$Shared <- ifelse(tub_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
tub_exons$Significant <- ifelse(
  tub_exons$FDR <=0.05 & tub_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tub_exons$FDR <=0.05 & tub_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tub_exons$negLogpvalue <- -log10(tub_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tub_exons <- tub_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tub_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tub_exons, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tub_exons, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Tubercidin - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Tubercidin Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "sans") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("final_plots/volcano_tub_exons.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("final_plots/volcano_tub_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72)


volcano_plot
```

### PladB

```{r plab fdr volcano exons}
pladb_exons<-pladb_fdr_df[grepl("EX",pladb_fdr_df$EVENT),]


# Add a Shared column based on the shared_exons
pladb_exons$Shared <- ifelse(pladb_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
pladb_exons$Significant <- ifelse(
  pladb_exons$FDR <=0.05 & pladb_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_exons$FDR <=0.05 & pladb_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_exons$negLogpvalue <- -log10(pladb_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_exons <- pladb_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_exons, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_exons, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (PladB - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("final_plots/volcano_pladb_exons.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("final_plots/volcano_pladb_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot


```


### Spliceostatin A

```{r ssa fdr volcano exons}
ssa_exons<-ssa_fdr_df[grepl("EX",ssa_fdr_df$EVENT),]


# Add a Shared column based on the shared_exons
ssa_exons$Shared <- ifelse(ssa_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
ssa_exons$Significant <- ifelse(
  ssa_exons$FDR <=0.05 & ssa_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    ssa_exons$FDR <=0.05 & ssa_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
ssa_exons$negLogpvalue <- -log10(ssa_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
ssa_exons <- ssa_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(ssa_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(ssa_exons, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(ssa_exons, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Spliceostatin A - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of SSA Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("final_plots/volcano_ssa_exons.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("final_plots/volcano_ssa_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot


```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition.


### Tubercidin

```{r tub combination table exons}
# Render DataTable with enhancements
datatable(
  differential_tub_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### PladB

```{r pladb combination table exons}
# Render DataTable with enhancements
datatable(
  differential_pladb_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### Spliceostatin A

```{r ssa combination table exons}
# Render DataTable with enhancements
datatable(
  differential_ssa_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

# Intron Lists

## Calculations

```{r pdiff calculation introns}

differential_tub_introns<-differential_tub[grepl("INT",differential_tub$EVENT),]
differential_pladb_introns<-differential_pladb[grepl("INT",differential_pladb$EVENT),]
differential_ssa_introns<-differential_ssa[grepl("INT",differential_ssa$EVENT),]


shared_introns<-intersect(differential_tub_introns$EVENT,differential_pladb_introns$EVENT)
shared_introns<-intersect(shared_introns,differential_ssa_introns$EVENT)


```



## Volcano Plots { .tabset}


### Tubercidin

```{r tub volcano introns}

tub_introns<-tub_fdr_df[grepl("INT",tub_fdr_df$EVENT),]

# Add a Shared column based on the shared_exons
tub_introns$Shared <- ifelse(tub_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
tub_introns$Significant <- ifelse(
  tub_introns$FDR <=0.05 & tub_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tub_introns$FDR <=0.05 & tub_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tub_introns$negLogpvalue <- -log10(tub_introns$FDR)


# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tub_introns <- tub_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tub_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tub_introns, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tub_introns, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Tubercidin - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Tubercidin Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_tub_introns.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_tub_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### PladB

```{r pladb volcano introns}
pladb_introns<-pladb_fdr_df[grepl("INT",pladb_fdr_df$EVENT),]

pladb_introns$Shared <- ifelse(pladb_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
pladb_introns$Significant <- ifelse(
  pladb_introns$FDR <=0.05 & pladb_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_introns$FDR <=0.05 & pladb_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_introns$negLogpvalue <- -log10(pladb_introns$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_introns <- pladb_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_introns, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_introns, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (PladB - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_pladb_introns.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_pladb_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### Spliceostatin A

```{r ssa volcano introns}
ssa_introns<-ssa_fdr_df[grepl("INT",ssa_fdr_df$EVENT),]

ssa_introns$Shared <- ifelse(ssa_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
ssa_introns$Significant <- ifelse(
  ssa_introns$FDR <=0.05 & ssa_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    ssa_introns$FDR <=0.05 & ssa_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
ssa_introns$negLogpvalue <- -log10(ssa_introns$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
ssa_introns <- ssa_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(ssa_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(ssa_introns, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(ssa_introns, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (SSA - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spliceostatin A Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_ssa_introns.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_ssa_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition.

### Tubercidin

```{r tub combination table introns}
# Render DataTable with enhancements
datatable(
  differential_tub_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### PladB


```{r pladb combination table introns}
# Render DataTable with enhancements
datatable(
  differential_pladb_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```

### Spliceostatin A


```{r ssa combination table introns}
# Render DataTable with enhancements
datatable(
  differential_ssa_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```


# Alternative 5´ & 3´

## Calculations

```{r pdiff calculation alt}

differential_tub_alt<-differential_tub[grepl("ALT",differential_tub$EVENT),]
differential_pladb_alt<-differential_pladb[grepl("ALT",differential_pladb$EVENT),]
differential_ssa_alt<-differential_ssa[grepl("ALT",differential_ssa$EVENT),]


shared_alt<-intersect(differential_tub_alt$EVENT,differential_pladb_alt$EVENT)
shared_alt<-intersect(shared_alt,differential_ssa_alt$EVENT)


```



## Volcano Plots { .tabset}


### Tubercidin

```{r tub volcano alt}

tub_alt<-tub_fdr_df[grepl("ALT",tub_fdr_df$EVENT),]

# Add a Shared column based on the shared_exons
tub_alt$Shared <- ifelse(tub_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
tub_alt$Significant <- ifelse(
  tub_alt$FDR <=0.05 & tub_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tub_alt$FDR <=0.05 & tub_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tub_alt$negLogpvalue <- -log10(tub_alt$FDR)


# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tub_alt <- tub_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tub_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tub_alt, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tub_alt, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Tubercidin - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Tubercidin Alt",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_tub_alt.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_tub_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### PladB

```{r pladb volcano alt}
pladb_alt<-pladb_fdr_df[grepl("ALT",pladb_fdr_df$EVENT),]

pladb_alt$Shared <- ifelse(pladb_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
pladb_alt$Significant <- ifelse(
  pladb_alt$FDR <=0.05 & pladb_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_alt$FDR <=0.05 & pladb_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_alt$negLogpvalue <- -log10(pladb_alt$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_alt <- pladb_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_alt, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_alt, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (PladB - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Alt",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_pladb_alt.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_pladb_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### Spliceostatin A

```{r ssa volcano alt}
ssa_alt<-ssa_fdr_df[grepl("ALT",ssa_fdr_df$EVENT),]

ssa_alt$Shared <- ifelse(ssa_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
ssa_alt$Significant <- ifelse(
  ssa_alt$FDR <=0.05 & ssa_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    ssa_alt$FDR <=0.05 & ssa_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
ssa_alt$negLogpvalue <- -log10(ssa_alt$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
ssa_alt <- ssa_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(ssa_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(ssa_alt, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(ssa_alt, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (SSA - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spliceostatin A Alt",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_ssa_alt.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_ssa_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition.

### Tubercidin

```{r tub combination table alt}
# Render DataTable with enhancements
datatable(
  differential_tub_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### PladB


```{r pladb combination table alt}
# Render DataTable with enhancements
datatable(
  differential_pladb_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```

### Spliceostatin A


```{r ssa combination table alt}
# Render DataTable with enhancements
datatable(
  differential_ssa_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```

# All Event Types Volcano Plots { .tabset}


## Tubercidin

```{r tub all volcano }

mega_volcano<-rbind(tub_introns,tub_exons,tub_alt)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Tubercidin - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Tubercidin All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_tub_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72)
ggsave("volcano_tub_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)

volcano_plot
```

## PladB

```{r pladb fdr volcano all}
mega_volcano<-rbind(pladb_alt,pladb_introns,pladb_exons)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (PladB - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_pladb_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72)
ggsave("volcano_pladb_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)

volcano_plot
```

## Spliceostatin A

```{r ssa fdr volcano all}
mega_volcano<-rbind(ssa_alt,ssa_introns,ssa_exons)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y,
                 color = Significant,
                 alpha = Significant,
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter,
                 color = Significant,
                 alpha = Significant,
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (SSA - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spliceostatin A All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_ssa_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72)
ggsave("volcano_ssa_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)

volcano_plot
```

# Basic Stats on Found Events

Only significant events

## Events-level stats

```{r basic stats}
# Define study-specific data
tub_exons_df <- data.frame(EVENT = differential_tub_exons$EVENT, Type = "Exons", Study = "Tubercidin")
tub_introns_df <- data.frame(EVENT = differential_tub_introns$EVENT, Type = "Introns", Study = "Tubercidin")
tub_alt_df <- data.frame(EVENT = differential_tub_alt$EVENT, Type = "Alt", Study = "Tubercidin")

pladb_exons_df <- data.frame(EVENT = differential_pladb_exons$EVENT, Type = "Exons", Study = "pladb")
pladb_introns_df <- data.frame(EVENT = differential_pladb_introns$EVENT, Type = "Introns", Study = "pladb")
pladb_alt_df <- data.frame(EVENT = differential_pladb_alt$EVENT, Type = "Alt", Study = "pladb")

ssa_exons_df <- data.frame(EVENT = differential_ssa_exons$EVENT, Type = "Exons", Study = "Spliceostatin")
ssa_introns_df <- data.frame(EVENT = differential_ssa_introns$EVENT, Type = "Introns", Study = "Spliceostatin")
ssa_alt_df <- data.frame(EVENT = differential_ssa_alt$EVENT, Type = "Alt", Study = "Spliceostatin")

# Define subsets for each event type
event_list_exons <- list(
  Tubercidin_Exons  = unique(tub_exons_df$EVENT),
  Pladb_Exons = unique(pladb_exons_df$EVENT),
  Spliceostatin_Exons = unique(ssa_exons_df$EVENT)
)

event_list_introns <- list(
  Tubercidin_Introns  = unique(tub_introns_df$EVENT),
  Pladb_Introns = unique(pladb_introns_df$EVENT),
  Spliceostatin_Introns = unique(ssa_introns_df$EVENT)
)

event_list_alt <- list(
  Tubercidin_Alt  = unique(tub_alt_df$EVENT),
  Pladb_Alt = unique(pladb_alt_df$EVENT),
  Spliceostatin_Alt = unique(ssa_alt_df$EVENT)
)

# Define colors
color_exons <- c("#4E79A7", "#4E79A7","#4E79A7")  # Blue for exons
color_introns <- c("#F28E2B", "#F28E2B","#F28E2B")  # Orange for introns
color_alt <- c("#E15759", "#E15759","#E15759")  # Red for alternative splicing events

# Generate UpSet plots
p_exons<-upset(fromList(event_list_exons),
                 nsets = 3,
                 order.by = "freq",
                 sets.bar.color = color_exons,
                 mainbar.y.label = "Exon Overlapping Events",
                 sets.x.label = "Number of Exon Events",
                 text.scale = 2)

p_introns <- upset(fromList(event_list_introns),
                   nsets = 3,
                   order.by = "freq",
                   sets.bar.color = color_introns,
                   mainbar.y.label = "Intron Overlapping Events",
                   sets.x.label = "Number of Intron Events",
                   text.scale = 2)

p_alt <- upset(fromList(event_list_alt),
               nsets = 3,
               order.by = "freq",
               sets.bar.color = color_alt,
               mainbar.y.label = "Alt Overlapping Events",
               sets.x.label = "Number of Alt Events",
               text.scale = 2)


p_exons
p_introns
p_alt
```
## GC Content and Length { .tabset}

### Spliceostatin A

```{r gc introns,out.width="100%"}
library(dplyr)
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(showtext)    # font_add_google(), showtext_auto()

# 1) Read event info
event_info <- read.delim("EVENT_INFO-mm10.tab")

# 2) GC function
gc_content <- function(seqs) {
  sapply(seqs, function(seq) {
    seq <- toupper(seq)
    gc  <- sum(strsplit(seq, "")[[1]] %in% c("G","C"))
    n   <- nchar(seq)
    if(n==0) return(NA)
    100 * gc / n
  })
}

# 3) Prepare DE introns
introns_gc <- differential_ssa_introns %>%
  left_join(select(event_info, EVENT, Seq_A, LE_o), by="EVENT") %>%
  mutate(
    gc        = gc_content(Seq_A),
    splicing  = if_else(deltapsi < 0, "Skipped", "Included")
  )

set.seed(123)
# 4) Prepare unchanged introns (you say you already have it in a DF)
unchanged_gc <- na.omit(introns_ssa_tub$PSI) %>%
  filter(!EVENT %in% differential_ssa_introns$EVENT) %>%
  left_join(select(event_info, EVENT, Seq_A, LE_o), by="EVENT") %>%
  filter(!is.na(Seq_A)) %>%
  sample_n(size = min(1000, n())) %>%
  mutate(
    gc       = gc_content(Seq_A),
    splicing = "Unchanged"
  )

# 5) Bind them & make factor
all_introns <- bind_rows(introns_gc, unchanged_gc) %>%
  mutate(
    splicing = factor(splicing,
                      levels = c("Included","Skipped","Unchanged"))
  )

# 6) Define pairwise comparisons
comparisons <- list(
  c("Included", "Skipped"),
  c("Included", "Unchanged"),
  c("Skipped",  "Unchanged")
)

# 7) Load Courier Prime
font_add_google("Courier Prime","courierprime")
showtext_auto()

# 8) Theme
pub_theme <- theme_minimal(base_family="courierprime", base_size=16) +
  theme(
    legend.position = "none",
    plot.title      = element_text(hjust=0.5, size=rel(1.2), face="bold"),
    axis.title      = element_text(size=rel(1.1)),
    axis.text       = element_text(size=rel(1.0)),
    panel.grid.major= element_line(size=0.2, color="grey80"),
    panel.grid.minor= element_blank()
  )

# 9) GC-content plot
p1 <- ggplot(all_introns, aes(x=splicing, y=gc, fill=splicing)) +
  geom_boxplot(outlier.shape=NA, alpha=0.8, width=0.6) +
  geom_jitter(width=0.15, alpha=0.4, size=1.5) +
  stat_compare_means(
    method      = "wilcox.test",
    comparisons = comparisons,
    label       = "p.signif",
    family      = "courierprime",
    label.size  = 5
  ) +
  scale_fill_manual(values=c("#0072B2","#D55E00","#009E73")) +
  labs(
    x     = "Splicing Outcome",
    y     = "GC Content (%)",
    title = "Spliceostatin A: Introns"
  ) +
  pub_theme

# 10) Length plot (with 95th percentile threshold)
threshold <- quantile(all_introns$LE_o, .95, na.rm=TRUE)
main_data <- all_introns %>% filter(LE_o <= threshold)
outliers  <- all_introns %>% filter(LE_o > threshold)

p2 <- ggplot(main_data, aes(x=splicing, y=LE_o, fill=splicing)) +
  geom_boxplot(outlier.shape=NA, alpha=0.8, width=0.6) +
  geom_jitter(width=0.15, alpha=0.4, size=1.5) +
  geom_point(
    data     = outliers,
    aes(x=splicing, y=threshold + 2),
    position = position_jitter(width=0.15),
    shape    = 21, size=3, fill="black", alpha=0.6
  ) +
  stat_compare_means(
    method      = "wilcox.test",
    comparisons = comparisons,
    label       = "p.signif",
    family      = "courierprime",
    label.size  = 5
  ) +
  coord_cartesian(ylim=c(min(main_data$LE_o, na.rm=TRUE), threshold+8)) +
  scale_fill_manual(values=c("#0072B2","#D55E00","#009E73")) +
  labs(
    x     = "Splicing Outcome",
    y     = "Intron Length (nt)") +
  pub_theme

# 11) Arrange side-by-side
grid.arrange(p1, p2, ncol=2)



```

### Pladienolide B

```{r gc introns pladb, out.width="100%"}
# 3) Prepare DE introns
introns_gc <- differential_pladb_introns %>%
  left_join(select(event_info, EVENT, Seq_A, LE_o), by="EVENT") %>%
  mutate(
    gc        = gc_content(Seq_A),
    splicing  = if_else(deltapsi < 0, "Skipped", "Included")
  )

set.seed(123)
# 4) Prepare unchanged introns (you say you already have it in a DF)
unchanged_gc <- na.omit(introns_pladb$PSI) %>%
  filter(!EVENT %in% differential_pladb_introns$EVENT) %>%
  left_join(select(event_info, EVENT, Seq_A, LE_o), by="EVENT") %>%
  filter(!is.na(Seq_A)) %>%
  sample_n(size = min(1000, n())) %>%
  mutate(
    gc       = gc_content(Seq_A),
    splicing = "Unchanged"
  )

# 5) Bind them & make factor
all_introns <- bind_rows(introns_gc, unchanged_gc) %>%
  mutate(
    splicing = factor(splicing,
                      levels = c("Included","Skipped","Unchanged"))
  )

# 6) Define pairwise comparisons
comparisons <- list(
  c("Included", "Skipped"),
  c("Included", "Unchanged"),
  c("Skipped",  "Unchanged")
)

# 7) Load Courier Prime
font_add_google("Courier Prime","courierprime")
showtext_auto()

# 8) Theme
pub_theme <- theme_minimal(base_family="courierprime", base_size=16) +
  theme(
    legend.position = "none",
    plot.title      = element_text(hjust=0.5, size=rel(1.2), face="bold"),
    axis.title      = element_text(size=rel(1.1)),
    axis.text       = element_text(size=rel(1.0)),
    panel.grid.major= element_line(size=0.2, color="grey80"),
    panel.grid.minor= element_blank()
  )

# 9) GC-content plot
p1 <- ggplot(all_introns, aes(x=splicing, y=gc, fill=splicing)) +
  geom_boxplot(outlier.shape=NA, alpha=0.8, width=0.6) +
  geom_jitter(width=0.15, alpha=0.4, size=1.5) +
  stat_compare_means(
    method      = "wilcox.test",
    comparisons = comparisons,
    label       = "p.signif",
    family      = "courierprime",
    label.size  = 5
  ) +
  scale_fill_manual(values=c("#0072B2","#D55E00","#009E73")) +
  labs(
    x     = "Splicing Outcome",
    y     = "GC Content (%)",
    title = "Pladienolide B: Introns"
  ) +
  pub_theme

# 10) Length plot (with 95th percentile threshold)
threshold <- quantile(all_introns$LE_o, .95, na.rm=TRUE)
main_data <- all_introns %>% filter(LE_o <= threshold)
outliers  <- all_introns %>% filter(LE_o > threshold)

p2 <- ggplot(main_data, aes(x=splicing, y=LE_o, fill=splicing)) +
  geom_boxplot(outlier.shape=NA, alpha=0.8, width=0.6) +
  geom_jitter(width=0.15, alpha=0.4, size=1.5) +
  geom_point(
    data     = outliers,
    aes(x=splicing, y=threshold + 2),
    position = position_jitter(width=0.15),
    shape    = 21, size=3, fill="black", alpha=0.6
  ) +
  stat_compare_means(
    method      = "wilcox.test",
    comparisons = comparisons,
    label       = "p.signif",
    family      = "courierprime",
    label.size  = 5
  ) +
  coord_cartesian(ylim=c(min(main_data$LE_o, na.rm=TRUE), threshold+8)) +
  scale_fill_manual(values=c("#0072B2","#D55E00","#009E73")) +
  labs(
    x     = "Splicing Outcome",
    y     = "Intron Length (nt)") +
  pub_theme

# 11) Arrange side-by-side
grid.arrange(p1, p2, ncol=2)
```

### Tuberdicin

```{r gc introns tub, out.width="100%"}

# 3) Prepare DE introns
introns_gc <- differential_tub_introns %>%
  left_join(select(event_info, EVENT, Seq_A, LE_o), by="EVENT") %>%
  mutate(
    gc        = gc_content(Seq_A),
    splicing  = if_else(deltapsi < 0, "Skipped", "Included")
  )

set.seed(123)
# 4) Prepare unchanged introns (you say you already have it in a DF)
unchanged_gc <- na.omit(introns_ssa_tub$PSI) %>%
  filter(!EVENT %in% differential_tub_introns$EVENT) %>%
  left_join(select(event_info, EVENT, Seq_A, LE_o), by="EVENT") %>%
  filter(!is.na(Seq_A)) %>%
  sample_n(size = min(1000, n())) %>%
  mutate(
    gc       = gc_content(Seq_A),
    splicing = "Unchanged"
  )

# 5) Bind them & make factor
all_introns <- bind_rows(introns_gc, unchanged_gc) %>%
  mutate(
    splicing = factor(splicing,
                      levels = c("Included","Skipped","Unchanged"))
  )

# 6) Define pairwise comparisons
comparisons <- list(
  c("Included", "Skipped"),
  c("Included", "Unchanged"),
  c("Skipped",  "Unchanged")
)

# 7) Load Courier Prime
font_add_google("Courier Prime","courierprime")
showtext_auto()

# 8) Theme
pub_theme <- theme_minimal(base_family="courierprime", base_size=16) +
  theme(
    legend.position = "none",
    plot.title      = element_text(hjust=0.5, size=rel(1.2), face="bold"),
    axis.title      = element_text(size=rel(1.1)),
    axis.text       = element_text(size=rel(1.0)),
    panel.grid.major= element_line(size=0.2, color="grey80"),
    panel.grid.minor= element_blank()
  )

# 9) GC-content plot
p1 <- ggplot(all_introns, aes(x=splicing, y=gc, fill=splicing)) +
  geom_boxplot(outlier.shape=NA, alpha=0.8, width=0.6) +
  geom_jitter(width=0.15, alpha=0.4, size=1.5) +
  stat_compare_means(
    method      = "wilcox.test",
    comparisons = comparisons,
    label       = "p.signif",
    family      = "courierprime",
    label.size  = 5
  ) +
  scale_fill_manual(values=c("#0072B2","#D55E00","#009E73")) +
  labs(
    x     = "Splicing Outcome",
    y     = "GC Content (%)",
    title = "Tubercidin: Introns"
  ) +
  pub_theme

# 10) Length plot (with 95th percentile threshold)
threshold <- quantile(all_introns$LE_o, .95, na.rm=TRUE)
main_data <- all_introns %>% filter(LE_o <= threshold)
outliers  <- all_introns %>% filter(LE_o > threshold)

p2 <- ggplot(main_data, aes(x=splicing, y=LE_o, fill=splicing)) +
  geom_boxplot(outlier.shape=NA, alpha=0.8, width=0.6) +
  geom_jitter(width=0.15, alpha=0.4, size=1.5) +
  geom_point(
    data     = outliers,
    aes(x=splicing, y=threshold + 2),
    position = position_jitter(width=0.15),
    shape    = 21, size=3, fill="black", alpha=0.6
  ) +
  stat_compare_means(
    method      = "wilcox.test",
    comparisons = comparisons,
    label       = "p.signif",
    family      = "courierprime",
    label.size  = 5
  ) +
  coord_cartesian(ylim=c(min(main_data$LE_o, na.rm=TRUE), threshold+8)) +
  scale_fill_manual(values=c("#0072B2","#D55E00","#009E73")) +
  labs(
    x     = "Splicing Outcome",
    y     = "Intron Length (nt)") +
  pub_theme

# 11) Arrange side-by-side
grid.arrange(p1, p2, ncol=2)
```

## Gene-level stats

```{r, basic gene stats}

gene_list <- list(
  Tubercidin  = unique(c(differential_tub_exons$GENE,differential_tub_introns$GENE,differential_tub_alt$GENE)),
  Pladb = unique(c(differential_pladb_exons$GENE,differential_pladb_introns$GENE,differential_pladb_alt$GENE)),
  Spliceostatin  = unique(c(differential_ssa_exons$GENE,differential_ssa_introns$GENE,differential_ssa_alt$GENE))
)


shared_genes<-intersect(gene_list$Tubercidin,gene_list$Pladb)
shared_genes<-intersect(shared_genes, gene_list$Spliceostatin)
# Generate UpSet plots
p_genes<-upset(fromList(gene_list),
                 nsets = 3,
                 order.by = "freq",
                 sets.bar.color = "#0099cf",
                 mainbar.y.label = "Overlapping Genes",
                 sets.x.label = "Number of Genes",
                 text.scale = 2)

p_genes
```



# Gene-centric Analysis { .tabset}

The following analysis identifies the number of significant events a given gene has. This number of *hits* serves as a proxy of how heavily influenced by splicing a given gene has been. The table shows how many genes classified by the number of significant events I have found, alongside the proportion of ORF disruption for each group. The plot then shows the list of genes, with at least 3 *hits*, in the x-axis, their average |dPSI| in the y-axis, and the shape of the points shows whether that given event is ORF-disrupted.

## Tubercidin

```{r gene-centric plot fmn2 prep}
# Set seed for reproducibility
set.seed(44)

# -------------------------------
# 0. Read protein impact data and combine your events
# -------------------------------
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE,
                             fill = TRUE, quote = "")

# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_tub_exons,
  introns = differential_tub_introns,
  alt = differential_tub_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  )

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF-shifted genes" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary,
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r fmn2 gene-centric plot, fig.width=24, fig.height=10}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.6) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in Tubercidin",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("final_plots/tub_splicing_events_plot.svg", plot = p2, width = 24, height = 10)

# Display the plot
print(p2)
```


## PladB

```{r gene-centric plot pladb prep}
# Set seed for reproducibility
set.seed(44)



# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_pladb_exons,
  introns = differential_pladb_introns,
  alt = differential_pladb_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  )

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF-shifted genes" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary,
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r pladb gene-centric plot, fig.width=30, fig.height=12}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.7) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in PladB",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("pladb_splicing_events_plot.svg", plot = p2, width = 30, height = 12, dpi = 300)

# Display the plot
print(p2)
```

## Spliceostatin A

```{r gene-centric plot ssa prep}
# Set seed for reproducibility
set.seed(44)



# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_ssa_exons,
  introns = differential_ssa_introns,
  alt = differential_ssa_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  )

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF-shifted genes" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary,
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r ssa gene-centric plot, fig.width=30, fig.height=12}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.7) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in Spliceostatin",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("ssa_splicing_events_plot.svg", plot = p2, width = 30, height = 12, dpi = 300)

# Display the plot
print(p2)
```

# Heatmap Tubercidin


```{r heatmap prep, results='hide', fig.show='hide'}
# Load required libraries
library(ComplexHeatmap)
library(circlize)
library(viridis)    # for viridis palette
library(dplyr)
library(grid)
library(tidyr)      # if needed for replace_na
library(enrichR)    # assuming enrichr() is from enrichR package

set.seed(44)

# --------------------------
# Data Preparation
# --------------------------
# Get unique splicing events (remove NA events) and convert selected PSI columns to matrix

tub_exons_df <- ssa_tub_events$PSI %>%
  filter(complete.cases(select(., 7:12)))

tub_unique <- tub_exons_df %>% distinct(EVENT, .keep_all = TRUE)
rownames(tub_unique) <- tub_unique$EVENT

# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_tub_exons$EVENT[abs(differential_tub_exons$deltapsi)>=0.1],
  differential_tub_introns$EVENT[abs(differential_tub_introns$deltapsi)>=0.1]
))
tub_unique <- tub_unique[rownames(tub_unique) %in% filtered_events, ] %>%
  select(7:12) %>%
  as.matrix()

# tub_mat: events × samples numeric matrix
robust_scaled <- t(
  apply(tub_unique, 1, function(x) {
    med <- median(x, na.rm = TRUE)
    mad <- mad(x, center = med, na.rm = TRUE)
    # avoid division by zero
    if (mad == 0) mad <- 1
    (x - med) / mad
  })
)

# If you’d rather bound the range to approx. [-2,2] you can then pmin/pmax:
tub_unique <- pmax(pmin(robust_scaled, 2), -2)


# Create a dendrogram for the columns (using hierarchical clustering on the transposed data)
col_dend <- hclust(dist(t(tub_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2)

# Define a color function using a viridis palette.
# Here we assume the PSI values range from 0 to 100 with a midpoint at 50.
col_fun <- colorRamp2(
  c(-2, 0, 2),
  viridis(3)
)

number_splices <- 4

# Create a reference table for enrichment analysis by combining events and genes
reference_table <- data.frame(
  EVENT = ssa_tub_events$PSI$EVENT,
  GENE = ssa_tub_events$PSI$GENE
  )


# --------------------------
# Initial Heatmap and Annotations
# --------------------------
# Calculate the initial heatmap to obtain cluster order
ht <- Heatmap(
  tub_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(8, "mm"),      # increased gap for white space between rows
  column_gap = unit(8, "mm"),   # increased gap for white space between columns
  rect_gp = gpar(col = "white", lwd = 0.3),
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),
    legend_direction = "vertical"
  )
)
ht <- draw(ht)
clustered_events <- row_order(ht)

# Build the left annotation: Protein impact points.
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")
events_for_impact <- rownames(tub_unique)
final_impact <- data.frame(EventID = rownames(tub_unique)) %>%
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),
    size = unit(4, "mm"),
    axis_param = list(
      side = "top",
      at = -2:2,
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45,
      gp = gpar(fontsize = 15)
    )
  )
)

# Perform enrichment analysis for each cluster and prepare right annotation text.
text_list <- list()
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(tub_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)




```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left. The PSI is shown as a Z-score.

```{r heatmap_plot, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

# --------------------------
# Final Heatmap with Annotations
# --------------------------

ht <- Heatmap(
  tub_unique, name = "PSI MAD",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Tuberdicin Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 10%",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  left_annotation = left_annotation,    # Protein impact annotation on left
  right_annotation = right_annotation,  # Enrichment annotation on right
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "black"),
  show_row_names = FALSE,
  row_gap = unit(5, "mm"),      # Increased white space between rows
  column_gap = unit(5,"mm"),   # Increased white space between columns
  rect_gp = gpar(col = "white", lwd = 0.1),  # Adjusted white grid visibility

)
ht <- draw(ht)

# Decorate the right annotation slices with the enrichment text.
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}
```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- tub_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

heatmap_dataframe_tub<-heatmap_dataframe
# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```




### Protein Impact on Splicing Events

I extracted the different subsets of significant splicing events and grouped them by the protein impact. The plot depicts that the protein impact does not alter the splicing tendency: some events (grey dots in the plot) will be included or excluded, but the population means of the WT and KO remain equal.

```{r protein impact psi tub}
# Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)
library(ggpubr)
library(matrixStats)
library(sysfonts)
library(showtext)

# Font settings
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()

tub_unique <- tub_exons_df %>% distinct(EVENT, .keep_all = TRUE)
rownames(tub_unique) <- tub_unique$EVENT
# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_tub_exons$EVENT[abs(differential_tub_exons$deltapsi)>=0.1],
  differential_tub_introns$EVENT[abs(differential_tub_introns$deltapsi)>=0.1]
))
tub_unique <- tub_unique[rownames(tub_unique) %in% filtered_events, ] %>%
  select(7:12) %>%
  as.matrix()

# Data prep
tub_mat <- tub_unique
original_cols <- colnames(tub_mat)

tub_df <- as.data.frame(tub_mat) %>%
  rownames_to_column("EVENT") %>%
  pivot_longer(
    cols = -EVENT,
    names_to = "sample",
    values_to = "value"
  ) %>%
  mutate(
    group_idx = match(sample, original_cols),
    protein_impact = final_impact_string$ONTO[match(EVENT, final_impact_string$EventID)],
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disrupted upon inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disrupted upon exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ NA_character_
    ),
    group = ceiling(group_idx / 3),
    condition = factor(if_else(stringr::str_detect(sample, "tub"), "Tubercidin", "Control"),
                       levels = c("Control", "Tubercidin"))
  ) %>%
  filter(!is.na(protein_impact)) %>%
  mutate(protein_impact = factor(protein_impact,
                                 levels = c("Alternative", "CDS impacted", "UTR", "ORF disrupted upon exclusion", "ORF disrupted upon inclusion"))) %>%
  select(-group_idx)

# Bootstrap confidence intervals
bootstrap_ci <- function(x, nboot = 1000, conf = 0.95) {
  boots <- replicate(nboot, mean(sample(x, replace = TRUE)))
  quantile(boots, c((1 - conf) / 2, 1 - (1 - conf) / 2), na.rm = TRUE)
}

summary_df <- tub_df %>%
  group_by(protein_impact, condition) %>%
  summarise(
    mean_val   = mean(value),
    n          = n(),
    ci_lower   = bootstrap_ci(value)[1],
    ci_upper   = bootstrap_ci(value)[2],
    .groups    = "drop"
  )

# Statistical testing
tests <- tub_df %>%
  group_by(protein_impact) %>%
  wilcox_test(value ~ condition, paired = TRUE) %>%
  adjust_pvalue(method = "BH") %>%
  add_significance() %>%
  add_xy_position(x = "condition", step.increase = 5)


# Plot
impact_psi_plot <- ggplot(summary_df, aes(x = condition, y = mean_val, color = protein_impact, fill = protein_impact)) +
  geom_jitter(data = tub_df, aes(x = condition, y = value), width = 0.2, size = 1.5, alpha = 0.4, color = "grey70", show.legend = FALSE) +
  geom_line(aes(group = protein_impact), size = 1.8) +
  geom_point(size = 3.2) +
  geom_ribbon(aes(x = as.numeric(condition), ymin = ci_lower, ymax = ci_upper, group = protein_impact), alpha = 0.25, color = NA) +
  stat_pvalue_manual(tests, label = "p.adj.signif", tip.length = 0.02, size = 1, bracket.size = 0.6, inherit.aes = FALSE) +
  facet_wrap(~ protein_impact, ncol = 3) +
  scale_y_continuous(
  breaks = seq(0, 100, by = 20),
  expand = expansion(mult = c(0, 0.1))) + # Add ~10% top padding
  coord_cartesian(ylim = c(0, 100)) + # Data range stays at 0–100
  scale_color_brewer(type = "qual", palette = "Set2") +
  scale_fill_brewer(type = "qual", palette = "Set2") +
  theme_minimal(base_family = "Courier Prime", base_size = 8) +
  theme(
    panel.grid.major = element_line(color = "grey80", size = 0.4),
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 3, family = "Courier Prime"),
    axis.title = element_text(face = "bold", size = 5),
    axis.text = element_text(size = 5),
    axis.text.x = element_text(angle = 45, hjust = 1),  # <-- Fix overlap
    legend.position = "none",
  ) +
  labs(
    x = "Condition",
    y = "PSI",
    color = "Protein Impact",
    fill = "Protein Impact"
  )

# Save
ggsave("final_plots/protein_impact_plot_tub_improved.png", impact_psi_plot, width = 16, height = 4, units = "in", dpi = 300)

impact_psi_plot



```


# Heatmap Spliceostatin A


```{r heatmap prep ssa, results='hide', fig.show='hide'}


set.seed(44)

# --------------------------
# Data Preparation
# --------------------------
# Get unique splicing events (remove NA events) and convert selected PSI columns to matrix

ssa_exons_df <- ssa_tub_events$PSI %>%
  filter(complete.cases(select(., c(7:9, 13:15))))

ssa_unique <- ssa_exons_df %>% distinct(EVENT, .keep_all = TRUE)
rownames(ssa_unique) <- ssa_unique$EVENT

ssa_unique_all<-ssa_unique
# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_ssa_exons$EVENT[abs(differential_ssa_exons$deltapsi)>=0.1],
  differential_ssa_introns$EVENT[abs(differential_ssa_introns$deltapsi)>=0.1]
))
ssa_unique <- ssa_unique[rownames(ssa_unique) %in% filtered_events, ] %>%
  select(c(7:9, 13:15)) %>%
  as.matrix()

# tub_mat: events × samples numeric matrix
robust_scaled <- t(
  apply(ssa_unique, 1, function(x) {
    med <- median(x, na.rm = TRUE)
    mad <- mad(x, center = med, na.rm = TRUE)
    # avoid division by zero
    if (mad == 0) mad <- 1
    (x - med) / mad
  })
)

# If you’d rather bound the range to approx. [-2,2] you can then pmin/pmax:
ssa_unique <- pmax(pmin(robust_scaled, 2), -2)


# Create a dendrogram for the columns (using hierarchical clustering on the transposed data)
col_dend <- hclust(dist(t(ssa_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2)

# Define a color function using a viridis palette.
# Here we assume the PSI values range from 0 to 100 with a midpoint at 50.
col_fun <- colorRamp2(
  c(-2, 0, 2),
  viridis(3)
)

number_splices <- 4

# Create a reference table for enrichment analysis by combining events and genes
reference_table <- data.frame(
  EVENT = ssa_tub_events$PSI$EVENT,
  GENE = ssa_tub_events$PSI$GENE
  )


# --------------------------
# Initial Heatmap and Annotations
# --------------------------
# Calculate the initial heatmap to obtain cluster order
ht <- Heatmap(
  ssa_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(8, "mm"),      # increased gap for white space between rows
  column_gap = unit(8, "mm"),   # increased gap for white space between columns
  rect_gp = gpar(col = "white", lwd = 0.3),
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),
    legend_direction = "vertical"
  )
)
ht <- draw(ht)
clustered_events <- row_order(ht)

# Build the left annotation: Protein impact points.
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")
events_for_impact <- rownames(ssa_unique)
final_impact <- data.frame(EventID = rownames(ssa_unique)) %>%
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),
    size = unit(4, "mm"),
    axis_param = list(
      side = "top",
      at = -2:2,
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45,
      gp = gpar(fontsize = 15)
    )
  )
)

# Perform enrichment analysis for each cluster and prepare right annotation text.
text_list <- list()
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(ssa_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}



```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot ssa, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

# --------------------------
# Final Heatmap with Annotations
# --------------------------

ht <- Heatmap(
  ssa_unique, name = "PSI MAD",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Spliceostatin A Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 10%",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  left_annotation = left_annotation,    # Protein impact annotation on left
  right_annotation = right_annotation,  # Enrichment annotation on right
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "black"),
  show_row_names = FALSE,
  row_gap = unit(5, "mm"),      # Increased white space between rows
  column_gap = unit(5,"mm"),   # Increased white space between columns
  rect_gp = gpar(col = "white", lwd = 0.1),  # Adjusted white grid visibility

)
ht <- draw(ht)

# Decorate the right annotation slices with the enrichment text.
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}
```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final ssa}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- ssa_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

heatmap_dataframe_ssa<-heatmap_dataframe
# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```



### Protein Impact on Splicing Events

I extracted the different subsets of significant splicing events and grouped them by the protein impact. The plot depicts that the protein impact does not alter the splicing tendency: some events (grey dots in the plot) will be included or excluded, but the population means of the WT and KO remain equal.

```{r protein impact psi ssa}
# Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)
library(ggpubr)
library(matrixStats)
library(sysfonts)
library(showtext)

# Font settings
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()

ssa_unique <- ssa_exons_df %>% distinct(EVENT, .keep_all = TRUE)
rownames(ssa_unique) <- ssa_unique$EVENT
# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_ssa_exons$EVENT[abs(differential_ssa_exons$deltapsi)>=0.1],
  differential_ssa_introns$EVENT[abs(differential_ssa_introns$deltapsi)>=0.1]
))
ssa_unique <- ssa_unique[rownames(ssa_unique) %in% filtered_events, ] %>%
  select(c(7:9,13:15)) %>%
  as.matrix()

# Data prep
ssa_mat <- ssa_unique
original_cols <- colnames(ssa_mat)

ssa_df <- as.data.frame(ssa_mat) %>%
  rownames_to_column("EVENT") %>%
  pivot_longer(
    cols = -EVENT,
    names_to = "sample",
    values_to = "value"
  ) %>%
  mutate(
    group_idx = match(sample, original_cols),
    protein_impact = final_impact_string$ONTO[match(EVENT, final_impact_string$EventID)],
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disrupted upon inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disrupted upon exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ NA_character_
    ),
    group = ceiling(group_idx / 3),
    condition = factor(if_else(stringr::str_detect(sample, "ssa"), "Spliceostatin A", "Control"),
                       levels = c("Control", "Spliceostatin A"))
  ) %>%
  filter(!is.na(protein_impact)) %>%
  mutate(protein_impact = factor(protein_impact,
                                 levels = c("Alternative", "CDS impacted", "UTR", "ORF disrupted upon exclusion", "ORF disrupted upon inclusion"))) %>%
  select(-group_idx)

# Bootstrap confidence intervals
bootstrap_ci <- function(x, nboot = 1000, conf = 0.95) {
  boots <- replicate(nboot, mean(sample(x, replace = TRUE)))
  quantile(boots, c((1 - conf) / 2, 1 - (1 - conf) / 2), na.rm = TRUE)
}

summary_df <- ssa_df %>%
  group_by(protein_impact, condition) %>%
  summarise(
    mean_val   = mean(value),
    n          = n(),
    ci_lower   = bootstrap_ci(value)[1],
    ci_upper   = bootstrap_ci(value)[2],
    .groups    = "drop"
  )

# Statistical testing
tests <- ssa_df %>%
  group_by(protein_impact) %>%
  wilcox_test(value ~ condition, paired = TRUE) %>%
  adjust_pvalue(method = "BH") %>%
  add_significance() %>%
  add_xy_position(x = "condition", step.increase = 5)


# Plot
impact_psi_plot <- ggplot(summary_df, aes(x = condition, y = mean_val, color = protein_impact, fill = protein_impact)) +
  geom_jitter(data = ssa_df, aes(x = condition, y = value), width = 0.2, size = 1.5, alpha = 0.4, color = "grey70", show.legend = FALSE) +
  geom_line(aes(group = protein_impact), size = 1.8) +
  geom_point(size = 3.2) +
  geom_ribbon(aes(x = as.numeric(condition), ymin = ci_lower, ymax = ci_upper, group = protein_impact), alpha = 0.25, color = NA) +
  stat_pvalue_manual(tests, label = "p.adj.signif", tip.length = 0.02, size = 1, bracket.size = 0.6, inherit.aes = FALSE) +
  facet_wrap(~ protein_impact, ncol = 3) +
  scale_y_continuous(
  breaks = seq(0, 100, by = 20),
  expand = expansion(mult = c(0, 0.1))) + # Add ~10% top padding
  coord_cartesian(ylim = c(0, 100)) + # Data range stays at 0–100
  scale_color_brewer(type = "qual", palette = "Set2") +
  scale_fill_brewer(type = "qual", palette = "Set2") +
  theme_minimal(base_family = "Courier Prime", base_size = 8) +
  theme(
    panel.grid.major = element_line(color = "grey80", size = 0.4),
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 3, family = "Courier Prime"),
    axis.title = element_text(face = "bold", size = 5),
    axis.text = element_text(size = 5),
    axis.text.x = element_text(angle = 45, hjust = 1),  # <-- Fix overlap
    legend.position = "none",
  ) +
  labs(
    x = "Condition",
    y = "PSI",
    color = "Protein Impact",
    fill = "Protein Impact"
  )

# Save
ggsave("final_plots/protein_impact_plot_ssa_improved.png", impact_psi_plot, width = 16, height = 4, units = "in", dpi = 300)

impact_psi_plot



```

# Heatmap Pladienolide B


```{r heatmap prep pladb, results='hide', fig.show='hide'}


set.seed(44)

# --------------------------
# Data Preparation
# --------------------------
# Get unique splicing events (remove NA events) and convert selected PSI columns to matrix

pladb_exons_df <- pladb_events$PSI %>%
  filter(complete.cases(select(., c(7:12))))

pladb_unique <- pladb_exons_df %>% distinct(EVENT, .keep_all = TRUE)
rownames(pladb_unique) <- pladb_unique$EVENT

# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_pladb_exons$EVENT[abs(differential_pladb_exons$deltapsi)>=0.1],
  differential_pladb_introns$EVENT[abs(differential_pladb_introns$deltapsi)>=0.1]
))

pladb_unique <- pladb_unique[rownames(pladb_unique) %in% filtered_events, ] %>%
  select(7:12) %>%
  as.matrix()

robust_scaled <- t(
  apply(pladb_unique, 1, function(x) {
    med <- median(x, na.rm = TRUE)
    mad <- mad(x, center = med, na.rm = TRUE)
    # avoid division by zero
    if (mad == 0) mad <- 1
    (x - med) / mad
  })
)

# If you’d rather bound the range to approx. [-2,2] you can then pmin/pmax:
pladb_unique <- pmax(pmin(robust_scaled, 2), -2)



# Create a dendrogram for the columns (using hierarchical clustering on the transposed data)
col_dend <- hclust(dist(t(pladb_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2)

# Define a color function using a viridis palette.
# Here we assume the PSI values range from 0 to 100 with a midpoint at 50.
col_fun <- colorRamp2(
  c(-2, 0, 2),
  viridis(3)
)

number_splices <- 4

# Create a reference table for enrichment analysis by combining events and genes
reference_table <- data.frame(
  EVENT = pladb_events$PSI$EVENT,
  GENE = pladb_events$PSI$GENE
  )


# --------------------------
# Initial Heatmap and Annotations
# --------------------------
# Calculate the initial heatmap to obtain cluster order
ht <- Heatmap(
  pladb_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(8, "mm"),      # increased gap for white space between rows
  column_gap = unit(8, "mm"),   # increased gap for white space between columns
  rect_gp = gpar(col = "white", lwd = 0.3),
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),
    legend_direction = "vertical"
  )
)
ht <- draw(ht)
clustered_events <- row_order(ht)

# Build the left annotation: Protein impact points.
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")
events_for_impact <- rownames(pladb_unique)
final_impact <- data.frame(EventID = rownames(pladb_unique)) %>%
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),
    size = unit(4, "mm"),
    axis_param = list(
      side = "top",
      at = -2:2,
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45,
      gp = gpar(fontsize = 15)
    )
  )
)

# Perform enrichment analysis for each cluster and prepare right annotation text.
text_list <- list()
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(pladb_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}



```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot pladb, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

# --------------------------
# Final Heatmap with Annotations
# --------------------------

ht <- Heatmap(
  pladb_unique, name = "PSI MAD",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Pladienolide B Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.2",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  left_annotation = left_annotation,    # Protein impact annotation on left
  right_annotation = right_annotation,  # Enrichment annotation on right
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "black"),
  show_row_names = FALSE,
  row_gap = unit(5, "mm"),      # Increased white space between rows
  column_gap = unit(5,"mm"),   # Increased white space between columns
  rect_gp = gpar(col = "white", lwd = 0.1),  # Adjusted white grid visibility

)
ht <- draw(ht)

# Decorate the right annotation slices with the enrichment text.
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}
```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final pladb}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- pladb_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

heatmap_dataframe_pladb<-heatmap_dataframe
# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```




### Protein Impact on Splicing Events

I extracted the different subsets of significant splicing events and grouped them by the protein impact. The plot depicts that the protein impact does not alter the splicing tendency: some events (grey dots in the plot) will be included or excluded, but the population means of the WT and KO remain equal.

```{r protein impact psi pladb}
# Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)
library(ggpubr)
library(matrixStats)
library(sysfonts)
library(showtext)

# Font settings
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()

pladb_unique <- pladb_exons_df %>% distinct(EVENT, .keep_all = TRUE)
rownames(pladb_unique) <- pladb_unique$EVENT
# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_pladb_exons$EVENT[abs(differential_pladb_exons$deltapsi)>=0.1],
  differential_pladb_introns$EVENT[abs(differential_pladb_introns$deltapsi)>=0.1]
))
pladb_unique <- pladb_unique[rownames(pladb_unique) %in% filtered_events, ] %>%
  select(7:12) %>%
  as.matrix()

# Data prep
pladb_mat <- pladb_unique
original_cols <- colnames(pladb_mat)

pladb_df <- as.data.frame(pladb_mat) %>%
  rownames_to_column("EVENT") %>%
  pivot_longer(
    cols = -EVENT,
    names_to = "sample",
    values_to = "value"
  ) %>%
  mutate(
    group_idx = match(sample, original_cols),
    protein_impact = final_impact_string$ONTO[match(EVENT, final_impact_string$EventID)],
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disrupted upon inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disrupted upon exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ NA_character_
    ),
    group = ceiling(group_idx / 3),
    condition = factor(if_else(stringr::str_detect(sample, "pladb"), "Pladienolide B", "Control"),
                       levels = c("Control", "Pladienolide B"))
  ) %>%
  filter(!is.na(protein_impact)) %>%
  mutate(protein_impact = factor(protein_impact,
                                 levels = c("Alternative", "CDS impacted", "UTR", "ORF disrupted upon exclusion", "ORF disrupted upon inclusion"))) %>%
  select(-group_idx)

# Bootstrap confidence intervals
bootstrap_ci <- function(x, nboot = 1000, conf = 0.95) {
  boots <- replicate(nboot, mean(sample(x, replace = TRUE)))
  quantile(boots, c((1 - conf) / 2, 1 - (1 - conf) / 2), na.rm = TRUE)
}

summary_df <- pladb_df %>%
  group_by(protein_impact, condition) %>%
  summarise(
    mean_val   = mean(value),
    n          = n(),
    ci_lower   = bootstrap_ci(value)[1],
    ci_upper   = bootstrap_ci(value)[2],
    .groups    = "drop"
  )

# Statistical testing
tests <- pladb_df %>%
  group_by(protein_impact) %>%
  wilcox_test(value ~ condition, paired = TRUE) %>%
  adjust_pvalue(method = "BH") %>%
  add_significance() %>%
  add_xy_position(x = "condition", step.increase = 5)


# Plot
impact_psi_plot <- ggplot(summary_df, aes(x = condition, y = mean_val, color = protein_impact, fill = protein_impact)) +
  geom_jitter(data = pladb_df, aes(x = condition, y = value), width = 0.2, size = 1.5, alpha = 0.4, color = "grey70", show.legend = FALSE) +
  geom_line(aes(group = protein_impact), size = 1.8) +
  geom_point(size = 3.2) +
  geom_ribbon(aes(x = as.numeric(condition), ymin = ci_lower, ymax = ci_upper, group = protein_impact), alpha = 0.25, color = NA) +
  stat_pvalue_manual(tests, label = "p.adj.signif", tip.length = 0.02, size = 1, bracket.size = 0.6, inherit.aes = FALSE) +
  facet_wrap(~ protein_impact, ncol = 3) +
  scale_y_continuous(
  breaks = seq(0, 100, by = 20),
  expand = expansion(mult = c(0, 0.1))) + # Add ~10% top padding
  coord_cartesian(ylim = c(0, 100)) + # Data range stays at 0–100
  scale_color_brewer(type = "qual", palette = "Set2") +
  scale_fill_brewer(type = "qual", palette = "Set2") +
  theme_minimal(base_family = "Courier Prime", base_size = 8) +
  theme(
    panel.grid.major = element_line(color = "grey80", size = 0.4),
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 3, family = "Courier Prime"),
    axis.title = element_text(face = "bold", size = 5),
    axis.text = element_text(size = 5),
    axis.text.x = element_text(angle = 45, hjust = 1),  # <-- Fix overlap
    legend.position = "none",
  ) +
  labs(
    x = "Condition",
    y = "PSI",
    color = "Protein Impact",
    fill = "Protein Impact"
  )

# Save
ggsave("final_plots/protein_impact_plot_pladb_improved.png", impact_psi_plot, width = 16, height = 4, units = "in", dpi = 300)

impact_psi_plot



```

# Enrichment Analysis with EnrichR of All Event Types { .tabset}

The following ontology analysis uses all significant events regardless of type. No background gene list was used for the following enrichment analysis. For a background-aware ontology analysis, check the *Metascape* analysis.

## Tubercidin { .tabset}

```{r tub enrichr}
enrichdata<-enrichr(unique(c(differential_tub$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


### GO Biological Process

```{r tub bioprocess, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Cellular Component

```{r tub cellcomponent, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Molecular Function

```{r tub molfunction, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

## Pladienolide B { .tabset}

```{r pladb enrichr}
enrichdata<-enrichr(unique(c(differential_pladb$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


### GO Biological Process

```{r pladb bioprocess, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Cellular Component

```{r pladb cellcomponent, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Molecular Function

```{r pladb molfunction, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


## Spliceostatin A { .tabset}

```{r ssa enrichr}
enrichdata<-enrichr(unique(c(differential_ssa$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


### GO Biological Process

```{r ssa bioprocess, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Cellular Component

```{r ssa cellcomponent, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Molecular Function

```{r ssa molfunction, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


# System Settings

```{r session info}
sessionInfo()
```
