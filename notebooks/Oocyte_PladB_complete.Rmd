---
title: "Oocyte Alternative Splicing Analysis"
subtitle: "PladB Treatment"
author: "Andrés Gordo Ortiz @Al Jord Lab CRG"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: flatly
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    code_folding: hide
    code_download: false
    df_print: paged
    number_sections: true

editor_options:
  markdown:
    wrap: 72

header-includes:
  - '<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">'
  - '<style>
        /* Base styling */
        body {
          font-family: "Roboto", sans-serif;
          color: #333;
          background-color: #ffffff;
          margin: 0;
          padding: 20px;
        }
        .container {
          max-width: 960px;
          margin: auto;
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 {
          color: #2C3E50;
          text-align: center;
          font-weight: 700;
          margin: 0.5em 0;
        }
        h1 { font-size: 2.5em; }
        h2 { font-size: 2em; }
        h3 { font-size: 1.75em; }
        
        /* Text styling */
        p {
          line-height: 1.6;
          margin-bottom: 1em;
          text-align: justify;
        }
        .subtitle, .author, .date {
          text-align: center;
          color: #2C3E50;
          margin-bottom: 0.5em;
        }
        
        /* Links */
        a {
          color: #0275d8;
          text-decoration: none;
        }
        a:hover {
          text-decoration: underline;
        }
        
        /* Tables */
        table {
          width: 100%;
          border-collapse: collapse;
          margin: 20px 0;
        }
        th, td {
          border: 1px solid #ddd;
          padding: 10px;
        }
        th {
          background-color: #2C3E50;
          color: #fff;
        }
        tr:nth-child(even) {
          background-color: #f9f9f9;
        }
        tr:hover {
          background-color: #f1f1f1;
        }
     </style>'
---




```{r setup, include=FALSE}
# Ensure a clean environment and load required libraries.
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)


# Load required libraries
library("betAS")
library("ggplot2")
library("plotly")
library("dplyr")
library("tidyverse")
library("cowplot")
library("DT")
library("paletteer")
library("ggupset")
library("showtext")
library("ggtext")
library("readxl")
library("biomaRt")
library("enrichR")
library("patchwork")
library("org.Mm.eg.db")
library("org.Hs.eg.db")
library("enrichplot")
library("DOSE")
library("clusterProfiler")
library("ComplexHeatmap")
library("enrichR")
library("colorRamp2")
library("dendextend")
# Register Google fonts
showtext_auto()
font_add_google("Roboto", "roboto")
font="roboto"


```

# Introduction to this Analysis

## Part 1: Upstream Analysis

The upstream analysis is performed on the CRG cluster using the Bash command line. This phase involves:

1. **Data Acquisition**:
  - Downloading `*.fastq.gz` files of these studies:
    - **Pladienolide B Treatment**
  - Merging technical replicates for superior sequencing depth. RNA Splicing analysis usually requires a minimum of 50 million reads per biological sample.

2. **Alignment**:
   - Aligning the sequences to the latest mouse genome release (mm10) using **Bowtie2** through the [Vast-Tools align function](https://link.springer.com/protocol/10.1007/978-1-0716-2521-7_7).

3. **Event Detection**:
   - Importing inclusion tables generated by Vast-Tools into RStudio. Vast-Tools does **not** find new splicing events, relaying on a manually curated database, [VASTDB](https://vastdb.crg.eu/), with more than 600.000 splicing events. The end result is an `Inclusion_table.tab`, which contains the splicing events as rows and the samples as columns. Splicing is quantified using the Percentage Spliced-In (PSI) parameter, which shows the percentage at which a given splicing event occurs across all sequencing reads of the gene. The database covers the following splicing events:
   
     - **Exons (EX)**: Cassette sequences that are either included or excluded in the mature mRNA.
     - **Introns (IN)**: Introns that are either retained or spliced out in the mature mRNA.
     - **Alternative 5' Splice Sites (Alt5)**: Exons that are spliced at different 5' sites (donor sites).
     - **Alternative 3' Splice Sites (Alt3)**: Exons that are spliced at different 3' sites (acceptor sites).
     - **Microexons (MIC)**: Exons that are shorter than 27 nucleotides.

---

## Part 2: Statistical Analysis

State-of-Art splicing analysis tools such as the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) employ a combination of statistical testing and simulations on the *beta* distribution to calculate the delta PSI (the difference in splicing between two conditions) and the False Discovery rate (FDR, or adjusted p-value) respectively. The specific steps taken for these analysis were.

1. **Statistical Testing**:
   - Use the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) in R to perform Beta Distribution simulations to obtain:
     - **False Discovery Rate (FDR)**
     - **delta Percentage Spliced-in (dPSI)**

2. **Filtering Criteria**: Significant events are defined by
     - FDR <= 0.05
     - |dPSI| >= 0.1 (out of 1. That is, at least a 10% increase or decrease in PSI)

All the code history can be accessed through its [GitHub Repository](https://github.com/andresgordoortiz/24crg_adel_manu_oocyte_splicing)

---

## Importing Inclusion Data

```{r inclusion tables}
pladb_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/pladb_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
pladb_events <- filterEvents(getEvents(pladb_data, tool = "vast-tools"), N=10) # Extract alternative splicing events
pladb_exons <- filterEvents(pladb_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 10)
pladb_alt <- filterEvents(pladb_events, types = c("Alt5", "Alt3"), N = 10)
pladb_introns <- filterEvents(pladb_events, types = c("IR"), N = 10)
```


## Metadata { .tabset}

### PladB

```{r metadata pladb}
# Load metadata file containing sample information
metadata_pladb <- read.csv(paste0(getwd(),"/metadata/metadata_pladb.csv"), sep = "\t")
metadata_pladb<-metadata_pladb[seq(1, nrow(metadata_pladb), by = 2),]
DT::datatable(metadata_pladb, options = list(pageLength = nrow(metadata_pladb), scrollX = TRUE))
```


---

# Total Splicing Events

This plot shows the total number of splicing events found during the **mapping**, alongside the proportions of each type of event. It is important to know that *vast-tools* does not find new events, but it identifies those manually curated in the database.

```{r splicing events barplot stacked}

# Adjusted version of the script
splicing_events <- tibble(
  event_type = names(pladb_events$EventsPerType),
  pladb = pladb_events$EventsPerType
)

splicing_events_long <- splicing_events %>%
  pivot_longer(cols = c(pladb),
               names_to = "study", values_to = "count") %>%
  mutate(event_type = ifelse(event_type %in% c("C1", "C2", "C3", "ANN", "S", "MIC"), "EX", event_type)) %>%
  group_by(study, event_type) %>%
  summarize(count = sum(count, na.rm = TRUE), .groups = "drop")

# Proportion bar plot
plot_proportion <- ggplot(splicing_events_long, aes(fill = event_type, y = count, x = study)) +
  geom_bar(position = "fill", stat = "identity") +
  labs(
    title = "<b style='font-size:18px;'>Proportion of Splicing Events by Study</b>",
    x = NULL,
    y = "Proportion of Events",
    fill = "Event Type"
  ) +
  theme_minimal(base_family = font) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    plot.title = element_markdown(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5)
  ) +
  scale_fill_paletteer_d("MetBrewer::Hokusai3")

splicing_events_long_sum<-splicing_events_long %>%
  dplyr::group_by(study) %>%
  summarize(count = sum(count))


# Absolute counts plot
plot_absolute <- ggplot(splicing_events_long_sum, aes(y = count, x = study)) +
  geom_point(color = "#C70039", size = 3) +
  geom_text(aes(label = count), vjust = -1, size = 4, check_overlap = TRUE) +
  labs(
    x = "Study",
    y = "Number of Events",
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal(base_family = font) +
  theme(
    legend.position = "none",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text( size=15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3)
  ) +
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.2)))


# Combine plots
combined_plot <- plot_proportion / plot_absolute +
  plot_layout(heights = c(1, 0.5)) &
  theme(plot.margin = margin(5,5, 0, 5))

ggsave("events_mapped_pladb.svg", plot = combined_plot, width = 10, height = 6, units = "in", dpi = 300)

# Display combined plot
combined_plot
```



```{r general stats}

vastdb_events<-read.table("EVENT_INFO-mm10.tab", header = TRUE, sep = "\t")
bin_exons <- function(n) {
  if (is.na(n)) return(NA) # Handle missing values
  else if (n < 6) return("1-5")
  else if (n < 9) return("6-10")
  else if (n < 21) return("11-20")
  else return("21+")
}

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_exons<-vastdb_events[grep("EX", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$exon_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_exons<-apply_bin_exons(vastdb_exons)

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_introns<-vastdb_events[grep("IN", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$intron_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_introns<-apply_bin_exons(vastdb_introns)

```

# Inclusion or Exclusion Plots { .tabset}

These plots show the distribution of the splicing change (dPSI) comparing the KO mutant vs the control. If there is a tendency towards inclusion or exclusion, the bell-shaped curve will be shifted to the right or left, respectively. First, I calculated the mean of each event per condition and then I calculated the difference between means for each event. The subtitle shows the Wilcoxon test assessing this possible asymmetry. The area under the curve for both sides (>0 and <0) is shown numerically. Only events with a dPSI greater or lower than 0 are shown for clarity.

## Exons 

```{r total of exons, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------
# Remove any NA rows (adjust as needed)
pladb_exons_df <- na.omit(pladb_exons$PSI)

# Function to compute the PSI difference for each row (KO - Control)
compute_difference <- function(df) {
  avg_10mm <- rowMeans(df[, 13:15])
  avg_control <- rowMeans(df[, 7:9])
  avg_10mm - avg_control
}

# Calculate the difference and remove any additional NAs
pladb_exons_df$difference <- compute_difference(pladb_exons_df)
pladb_exons_df <- na.omit(pladb_exons_df)

# Create a group variable based on whether the difference is below or above zero
pladb_exons_df$group <- ifelse(pladb_exons_df$difference < 0, "Skipped", "Included")

# Perform a one-sample Wilcoxon signed-rank test (null hypothesis: median = 0)
symmetry_test <- wilcox.test(pladb_exons_df$difference, mu = 0)

# Compute the percentages (areas under the density curve)
pct_below <- round(mean(pladb_exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(pladb_exons_df$difference > 0) * 100, 1)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  pladb_exons_df[abs(pladb_exons_df$difference) > 0, ], 
  aes(x = difference, fill = group)
) +
  geom_histogram(aes(y = ..density..), bins = 200, 
                 position = "identity", alpha = 0.9) +
  labs(
    title = "PSI Difference Distribution of Exons PladB",
    subtitle = paste("One-sample Wilcoxon test p-value for Symmetry:", 
                     format(symmetry_test$p.value, digits = 3)),
    x = "ΔPSI (PladB10mM - Control)",
    y = "Density",
    fill = "Splicing Direction",
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3),
    strip.text = element_text(size = 14, face = "bold"),
    panel.spacing = unit(1.5, "lines")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("dPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "blue", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("dPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "red", size = 7, fontface = "bold",
           label.size = 0.5) +
  scale_fill_brewer(palette = "Set1")

# Save and display the plot
ggsave("pladb_psi_distribution_exons.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)

```



## Introns

```{r inclusionumber of introns, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------
# Remove any NA rows (adjust as needed)
pladb_introns_df <- na.omit(pladb_introns$PSI)

# Function to compute the PSI difference for each row (KO - Control)
compute_difference <- function(df) {
  avg_10mm <- rowMeans(df[, 13:15])
  avg_control <- rowMeans(df[, 7:9])
  avg_10mm - avg_control
}

# Calculate the difference and remove any additional NAs
pladb_introns_df$difference <- compute_difference(pladb_introns_df)
pladb_introns_df <- na.omit(pladb_introns_df)

# Create a group variable based on whether the difference is below or above zero
pladb_introns_df$group <- ifelse(pladb_introns_df$difference < 0, "Skipped", "Included")

# Perform a one-sample Wilcoxon signed-rank test (null hypothesis: median = 0)
symmetry_test <- wilcox.test(pladb_introns_df$difference, mu = 0)

# Compute the percentages (areas under the density curve)
pct_below <- round(mean(pladb_introns_df$difference < 0) * 100, 1)
pct_above <- round(mean(pladb_introns_df$difference > 0) * 100, 1)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  pladb_introns_df[abs(pladb_introns_df$difference) > 0, ], 
  aes(x = difference, fill = group)
) +
  geom_histogram(aes(y = ..density..), bins = 200, 
                 position = "identity", alpha = 0.9) +
  labs(
    title = "PSI Difference Distribution of Introns PladB",
    subtitle = paste("One-sample Wilcoxon test p-value for Symmetry:", 
                     format(symmetry_test$p.value, digits = 3)),
    x = "ΔPSI (PladB10mM - Control)",
    y = "Density",
    fill = "Splicing Direction",
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3),
    strip.text = element_text(size = 14, face = "bold"),
    panel.spacing = unit(1.5, "lines")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("dPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "blue", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("dPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "red", size = 7, fontface = "bold",
           label.size = 0.5) +
  scale_fill_brewer(palette = "Set1")

# Save and display the plot
ggsave("pladb_psi_distribution_introns.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)

```


# Does the number of exons of a gene affect Inclusion? { .tabset}

First I classified the genes according to the number of exons they contain from VASTDB. Then I plotted the dPSI of all exons grouped by that classification.

## Exons 


```{r inclusionumber of exons pladb, fig.width=12, fig.height=8}
# Remove NAs and filter values where |dPSI| > 0
pladb_exons_df <- na.omit(pladb_exons$PSI)
pladb_exons_df$exon_group <- vastdb_exons$exon_group[match(pladb_exons_df$EVENT, vastdb_exons$EVENT)]

# Function to compute PSI difference
compute_difference <- function(df) {
  avg_10mm <- rowMeans(df[, 13:15])
  avg_control <- rowMeans(df[, 7:9])
  avg_10mm - avg_control
}

# Compute the difference and assign exon group factors
pladb_exons_df$difference <- compute_difference(pladb_exons_df)
pladb_exons_df$exon_group <- factor(pladb_exons_df$exon_group, levels = c("1-5", "6-10", "11-20", "21+"))

# Keep only |dPSI| > 0
pladb_exons_filtered <- na.omit(pladb_exons_df[abs(pladb_exons_df$difference) > 0, ])

# Compute percentages and Wilcoxon test for each exon group
stats_summary <- pladb_exons_filtered %>%
  group_by(exon_group) %>%
  summarize(
    pct_below = round(mean(difference < 0, na.rm = TRUE) * 100, 1),
    pct_above = round(mean(difference > 0, na.rm = TRUE) * 100, 1),
    p_value = format(wilcox.test(difference, mu = 0)$p.value, digits = 3)
  )

# Plot distribution of PSI difference
plot_psi_distribution <- ggplot(
  pladb_exons_filtered, 
  aes(x = difference, fill = ifelse(difference < 0, "Skipped", "Included"))
) +
  geom_histogram(aes(y = ..density..), bins = 200, position = "identity", alpha = 0.9) +
  facet_wrap(~exon_group, scales = "fixed") +
  labs(
    title = "PSI Difference Distribution Grouped by Exon Count per Gene",
    subtitle = "PladB: ΔPSI = 10mM - Control",
    x = "ΔPSI (PladB10mM - Control)",
    y = "Density",
    fill = "Splicing Direction",
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3),
    strip.text = element_text(size = 14, face = "bold"),
    panel.spacing = unit(1.5, "lines")
  ) +
  scale_x_continuous(breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)) +
  scale_fill_brewer(palette = "Set1") +
  
  # Annotate percentages
  geom_text(
    data = stats_summary, aes(x = -65, y = 0.1, label = sprintf("dPSI < 0: %.1f%%", pct_below)),
    inherit.aes = FALSE, hjust = 0, vjust = 0, size = 5, fontface = "bold", color = "blue"
  ) +
  geom_text(
    data = stats_summary, aes(x = 65, y = 0.1, label = sprintf("dPSI > 0: %.1f%%", pct_above)),
    inherit.aes = FALSE, hjust = 1, vjust = 0, size = 5, fontface = "bold", color = "red"
  ) +
  
  # Annotate Wilcoxon p-values
  geom_text(
    data = stats_summary, aes(x = 0, y = 0.08, label = sprintf("p = %s", p_value)),
    inherit.aes = FALSE, hjust = 0.5, vjust = 0, size = 5, fontface = "italic", color = "black"
  )

# Save and display
ggsave("number_genes_pladb_psi_distribution_exons.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)
print(plot_psi_distribution)


```

## Introns

```{r inclusionumber of introns pladb, fig.width=12, fig.height=8}
# Remove NAs and filter values where |dPSI| > 0
pladb_introns_df <- na.omit(pladb_introns$PSI)
pladb_introns_df$intron_group <- vastdb_introns$intron_group[match(pladb_introns_df$EVENT, vastdb_introns$EVENT)]

# Function to compute PSI difference
compute_difference <- function(df) {
  avg_10mm <- rowMeans(df[, 13:15])
  avg_control <- rowMeans(df[, 7:9])
  avg_10mm - avg_control
}

# Compute the difference and assign exon group factors
pladb_introns_df$difference <- compute_difference(pladb_introns_df)
pladb_introns_df$intron_group <- factor(pladb_introns_df$intron_group, levels = c("1-5", "6-10", "11-20", "21+"))

# Keep only |dPSI| > 0
pladb_introns_filtered <- na.omit(pladb_introns_df[abs(pladb_introns_df$difference) > 0, ])

# Compute percentages and Wilcoxon test for each exon group
stats_summary <- pladb_introns_filtered %>%
  group_by(intron_group) %>%
  summarize(
    pct_below = round(mean(difference < 0, na.rm = TRUE) * 100, 1),
    pct_above = round(mean(difference > 0, na.rm = TRUE) * 100, 1),
    p_value = format(wilcox.test(difference, mu = 0)$p.value, digits = 3)
  )

# Plot distribution of PSI difference
plot_psi_distribution <- ggplot(
  pladb_introns_filtered, 
  aes(x = difference, fill = ifelse(difference < 0, "Skipped", "Included"))
) +
  geom_histogram(aes(y = ..density..), bins = 200, position = "identity", alpha = 0.9) +
  facet_wrap(~intron_group, scales = "fixed") +
  labs(
    title = "PSI Difference Distribution Grouped by Intron Count per Gene",
    subtitle = "PladB: ΔPSI = 10mM - Control",
    x = "ΔPSI (PladB10mM - Control)",
    y = "Density",
    fill = "Splicing Direction",
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3),
    strip.text = element_text(size = 14, face = "bold"),
    panel.spacing = unit(1.5, "lines")
  ) +
  scale_x_continuous(breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)) +
  scale_fill_brewer(palette = "Set1") +
  
  # Annotate percentages
  geom_text(
    data = stats_summary, aes(x = -65, y = 0.1, label = sprintf("dPSI < 0: %.1f%%", pct_below)),
    inherit.aes = FALSE, hjust = 0, vjust = 0, size = 5, fontface = "bold", color = "blue"
  ) +
  geom_text(
    data = stats_summary, aes(x = 65, y = 0.1, label = sprintf("dPSI > 0: %.1f%%", pct_above)),
    inherit.aes = FALSE, hjust = 1, vjust = 0, size = 5, fontface = "bold", color = "red"
  ) +
  
  # Annotate Wilcoxon p-values
  geom_text(
    data = stats_summary, aes(x = 0, y = 0.08, label = sprintf("p = %s", p_value)),
    inherit.aes = FALSE, hjust = 0.5, vjust = 0, size = 5, fontface = "italic", color = "black"
  )

# Save and display
ggsave("number_genes_pladb_psi_distribution_introns.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)
print(plot_psi_distribution)


```



# PCA Plot { .tabset}

## PladB

```{r pca calculation}
# Subset and scale data
pca_pladb <- pladb_data[, c("EVENT",pladb_events$Samples)] %>%
  na.omit()

rownames(pca_pladb)<- pca_pladb$EVENT
pca_pladb<-t(pca_pladb[,-1])


pca_result_pladb <- prcomp(pca_pladb)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result_pladb$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-metadata_pladb$Description
```

```{r pca plotting}
# Create PCA plot
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition), )) +
  geom_point(size = 6) +
  labs(
    title = "<b style='font-size:18px;'>PCA of Samples (PSI Data)</b>",
    x = paste("PC1 (", round(100 * summary(pca_result_pladb)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result_pladb)$importance[2, 2], 1), "%)", sep = ""),
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal(base_family = "roboto") +
  theme(
    plot.title = element_markdown(),
    plot.title.position = "plot",
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_blank()
  ) +
  scale_colour_paletteer_d("MetBrewer::Hokusai3") +
  coord_fixed()

pca_plot

```


# Differential Splicing Calculation

```{r aux_featuregroup}
# Extract unique groups and sample IDs
# pladb

groupingVariable <- "Description"


groups_pladb <- unique(metadata_pladb[, groupingVariable])
samples_pladb <- metadata_pladb$fastq_files
samples_pladb <- paste0(
  "X",
  sub("\\.fastq\\.gz$", "", samples_pladb),
  "_merged"
)


random_colors=c("#D8D97AFF", "#95C36EFF", "#74C8C3FF", "#5A97C1FF", "#295384FF", "#0A2E57FF")

# Create group list with metadata
groupList_pladb <- lapply(1:length(groups_pladb), function(i) {
  list(
    name = groups_pladb[i],
    samples = samples_pladb[metadata_pladb[, groupingVariable] == groups_pladb[i]],
    color = random_colors[i]
  )
})
names(groupList_pladb) <- groups_pladb

```

```{r groups_auxiliary}
# Define groups
groupA_pladb    <- "ControlFmn2+-"
groupC_pladb    <- "Fmn2+-_+1mMPlatB"
groupB_pladb <- "Fmn2+-_+10mMPlatB"

# Define samples inside each group
samplesA_pladb    <- groupList_pladb[[groupA_pladb]]$samples
samplesB_pladb    <- groupList_pladb[[groupB_pladb]]$samples
samplesC_pladb    <- groupList_pladb[[groupC_pladb]]$samples
colsGroupA_pladb    <- convertCols(pladb_exons$PSI, samplesA_pladb)
colsGroupB_pladb   <- convertCols(pladb_exons$PSI, samplesB_pladb)
colsGroupC_pladb   <- convertCols(pladb_exons$PSI, samplesC_pladb)

```

## Exon Lists

### Calculations

```{r pdiff calculation exons}


pladb_pdiff_exons <- prepareTableVolcanoFDR(
  psitable = pladb_exons$PSI,
  qualtable = pladb_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_pladb,
  colsB = colsGroupB_pladb,
  labA = groupA_pladb,
  labB = groupB_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed=TRUE,
  CoverageWeight = FALSE)

pladb_1mm_control_pdiff_exons <- prepareTableVolcanoFDR(
  psitable = pladb_exons$PSI,
  qualtable = pladb_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_pladb,
  colsB = colsGroupC_pladb,
  labA = groupA_pladb,
  labB = groupC_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed=TRUE,
  CoverageWeight = FALSE)

pladb_1mm_10mm_pdiff_exons <- prepareTableVolcanoFDR(
  psitable = pladb_exons$PSI,
  qualtable = pladb_exons$Qual,
  npoints = 500,
  colsA = colsGroupC_pladb,
  colsB = colsGroupB_pladb,
  labA = groupC_pladb,
  labB = groupB_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed=TRUE,
  CoverageWeight = FALSE)

write.csv(pladb_pdiff_exons,"pladb_pdiff_exons.csv")
write.csv(pladb_1mm_control_pdiff_exons,"pladb_1mm_control_pdiff_exons.csv")
write.csv(pladb_1mm_10mm_pdiff_exons,"pladb_1mm_10mm_pdiff_exons.csv")
```




### FDR Volcano Plots { .tabset}

Volcano Plots of the FDR corrected exons for each study. In pink are the exons with a deltaPSI>=0.1.

#### PladB 10mM vs Control

```{r pladb fdr volcano exons 10mm control}
# INtersecting dhared exons between 10mm vs control and 1mm vs control
differential_pladb10mm_exons<-na.omit(pladb_pdiff_exons[pladb_pdiff_exons$FDR<=0.05 & abs(pladb_pdiff_exons$deltapsi)>=0.1,])
differential_pladb1mm_exons<-na.omit(pladb_1mm_control_pdiff_exons[pladb_1mm_control_pdiff_exons$FDR<=0.05 & abs(pladb_1mm_control_pdiff_exons$deltapsi)>=0.1,])
differential_pladb10mm_1mm_exons<-na.omit(pladb_1mm_10mm_pdiff_exons[pladb_1mm_10mm_pdiff_exons$FDR<=0.05 & abs(pladb_1mm_10mm_pdiff_exons$deltapsi)>=0.1,])

shared_exons<-differential_pladb10mm_exons$EVENT[differential_pladb10mm_exons$EVENT %in% differential_pladb1mm_exons$EVENT]

# Volcano plot
library(ggrepel)
pladb_pdiff_exons<-na.omit(pladb_pdiff_exons)
# Add a Shared column based on the shared_exons
pladb_pdiff_exons$Shared <- ifelse(pladb_pdiff_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
pladb_pdiff_exons$Significant <- ifelse(
  pladb_pdiff_exons$FDR<=0.05 & pladb_pdiff_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_pdiff_exons$FDR<=0.05 & pladb_pdiff_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_pdiff_exons$negLogpvalue <- -log10(pladb_pdiff_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_pdiff_exons <- pladb_pdiff_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_pdiff_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_pdiff_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_pdiff_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (10mM - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_exons_10mm_control.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

#### PladB 1mM vs Control

```{r pladb fdr volcano exons 1mm control}
pladb_1mm_control_pdiff_exons<-na.omit(pladb_1mm_control_pdiff_exons)
# Add a Shared column based on the shared_exons
pladb_1mm_control_pdiff_exons$Shared <- ifelse(pladb_1mm_control_pdiff_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
pladb_1mm_control_pdiff_exons$Significant <- ifelse(
  pladb_1mm_control_pdiff_exons$FDR<=0.05 & pladb_1mm_control_pdiff_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_1mm_control_pdiff_exons$FDR<=0.05 & pladb_1mm_control_pdiff_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_1mm_control_pdiff_exons$negLogpvalue <- -log10(pladb_1mm_control_pdiff_exons$FDR)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_1mm_control_pdiff_exons <- pladb_1mm_control_pdiff_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_1mm_control_pdiff_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_1mm_control_pdiff_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_1mm_control_pdiff_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (1mM - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_exons_1mm_control.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

#### PladB 10mM vs 1mM

```{r pladb fdr volcano exons 10mm 1mm}
pladb_1mm_10mm_pdiff_exons<-na.omit(pladb_1mm_10mm_pdiff_exons)
# Add a Shared column based on the shared_exons
pladb_1mm_10mm_pdiff_exons$Shared <- ifelse(pladb_1mm_10mm_pdiff_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
pladb_1mm_10mm_pdiff_exons$Significant <- ifelse(
  pladb_1mm_10mm_pdiff_exons$FDR<=0.05 & pladb_1mm_10mm_pdiff_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_1mm_10mm_pdiff_exons$FDR<=0.05 & pladb_1mm_10mm_pdiff_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_1mm_10mm_pdiff_exons$negLogpvalue <- -log10(pladb_1mm_10mm_pdiff_exons$FDR)


max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_1mm_10mm_pdiff_exons <- pladb_1mm_10mm_pdiff_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_1mm_10mm_pdiff_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_1mm_10mm_pdiff_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_1mm_10mm_pdiff_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (10mM - 1mM)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_exons_10mm_1mm.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot

```


### Individual Combination Tables { .tabset}

These tables show the exons that show a FDR<=0.1 in the pairwise comparison of each condition.


#### PladB 10mM vs control


```{r pladb combination table exons 10mm control}
# Render DataTable with enhancements
datatable(
  differential_pladb10mm_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```

#### PladB 1mM vs Control

```{r pladb combination table exons 1mm control}
# Render DataTable with enhancements
datatable(
  differential_pladb1mm_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

#### PladB 10mM vs 1mM

```{r pladb combination table exons 10mm 1mm}
# Render DataTable with enhancements
datatable(
  differential_pladb10mm_1mm_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```


#### Shared Exons in 10mM vs control & 1mM vs control

```{r pladb combination table exons shared}
shared_exons_datatable<-pladb_pdiff_exons[pladb_pdiff_exons$EVENT %in% shared_exons,]
# Render DataTable with enhancements
datatable(
  shared_exons_datatable,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

## Intron Lists

### Calculations

```{r pdiff calculation introns}


pladb_pdiff_introns <- prepareTableVolcanoFDR(
  psitable = pladb_introns$PSI,
  qualtable = pladb_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_pladb,
  colsB = colsGroupB_pladb,
  labA = groupA_pladb,
  labB = groupB_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000, 
  seed=TRUE, 
  CoverageWeight = FALSE) 

pladb_1mm_control_pdiff_introns <- prepareTableVolcanoFDR(
  psitable = pladb_introns$PSI,
  qualtable = pladb_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_pladb,
  colsB = colsGroupC_pladb,
  labA = groupA_pladb,
  labB = groupC_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000, 
  seed=TRUE, 
  CoverageWeight = FALSE) 

pladb_1mm_10mm_pdiff_introns <- prepareTableVolcanoFDR(
  psitable = pladb_introns$PSI,
  qualtable = pladb_introns$Qual,
  npoints = 500,
  colsA = colsGroupC_pladb,
  colsB = colsGroupB_pladb,
  labA = groupC_pladb,
  labB = groupB_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000, 
  seed=TRUE, 
  CoverageWeight = FALSE) 

write.csv(pladb_pdiff_introns,"pladb_pdiff_introns.csv")
write.csv(pladb_1mm_control_pdiff_introns,"pladb_1mm_control_pdiff_introns.csv")
write.csv(pladb_1mm_10mm_pdiff_introns,"pladb_1mm_10mm_pdiff_introns.csv")
```


### FDR Volcano Plots { .tabset}

Volcano Plots of the FDR corrected exons for each study.

#### PladB 10mM vs Control

```{r pladb fdr volcano introns 10mm control}
# INtersecting dhared introns between 10mm vs control and 1mm vs control
differential_pladb10mm_introns<-na.omit(pladb_pdiff_introns[pladb_pdiff_introns$FDR<=0.05 & abs(pladb_pdiff_introns$deltapsi) >= 0.1,])
differential_pladb1mm_introns<-na.omit(pladb_1mm_control_pdiff_introns[pladb_1mm_control_pdiff_introns$FDR<=0.05 & abs(pladb_1mm_control_pdiff_introns$deltapsi) >= 0.1,])

differential_pladb10mm_1mm_introns<-na.omit(pladb_1mm_10mm_pdiff_introns[pladb_1mm_10mm_pdiff_introns$FDR<=0.05 & abs(pladb_1mm_10mm_pdiff_introns$deltapsi) >= 0.1,])

shared_introns<-differential_pladb10mm_introns$EVENT[differential_pladb10mm_introns$EVENT %in% differential_pladb1mm_introns$EVENT]

# Volcano plot
library(ggrepel)
pladb_pdiff_introns<-na.omit(pladb_pdiff_introns)
# Add a Shared column based on the shared_introns
pladb_pdiff_introns$Shared <- ifelse(pladb_pdiff_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
pladb_pdiff_introns$Significant <- ifelse(
  pladb_pdiff_introns$FDR<=0.05 & pladb_pdiff_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_pdiff_introns$FDR<=0.05 & pladb_pdiff_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_pdiff_introns$negLogpvalue <- -log10(pladb_pdiff_introns$FDR)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_pdiff_introns <- pladb_pdiff_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_pdiff_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_pdiff_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_pdiff_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (10mM - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_introns_10mm_control.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

#### PladB 1mM vs Control

```{r pladb fdr volcano introns 1mm control}
pladb_1mm_control_pdiff_introns<-na.omit(pladb_1mm_control_pdiff_introns)
# Add a Shared column based on the shared_introns
pladb_1mm_control_pdiff_introns$Shared <- ifelse(pladb_1mm_control_pdiff_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
pladb_1mm_control_pdiff_introns$Significant <- ifelse(
  pladb_1mm_control_pdiff_introns$FDR<=0.05 & pladb_1mm_control_pdiff_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_1mm_control_pdiff_introns$FDR<=0.05 & pladb_1mm_control_pdiff_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_1mm_control_pdiff_introns$negLogpvalue <- -log10(pladb_1mm_control_pdiff_introns$FDR)


max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_1mm_control_pdiff_introns <- pladb_1mm_control_pdiff_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_1mm_control_pdiff_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_1mm_control_pdiff_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_1mm_control_pdiff_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (1mM - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_introns_1mm_control.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot

```

#### PladB 10mM vs 1mM

```{r pladb fdr volcano introns 10mm 1mm}
pladb_1mm_10mm_pdiff_introns<-na.omit(pladb_1mm_10mm_pdiff_introns)
# Add a Shared column based on the shared_introns
pladb_1mm_10mm_pdiff_introns$Shared <- ifelse(pladb_1mm_10mm_pdiff_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
pladb_1mm_10mm_pdiff_introns$Significant <- ifelse(
  pladb_1mm_10mm_pdiff_introns$FDR<=0.05 & pladb_1mm_10mm_pdiff_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_1mm_10mm_pdiff_introns$FDR<=0.05 & pladb_1mm_10mm_pdiff_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_1mm_10mm_pdiff_introns$negLogpvalue <- -log10(pladb_1mm_10mm_pdiff_introns$FDR)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_1mm_10mm_pdiff_introns <- pladb_1mm_10mm_pdiff_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_1mm_10mm_pdiff_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_1mm_10mm_pdiff_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_1mm_10mm_pdiff_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (10mM - 1mM)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_introns_10mm_1mm.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot

```



### Individual Combination Tables { .tabset}

These tables show the introns with a FDR<=0.05 in the pairwise comparison of each condition.

#### PladB 10mM vs control


```{r pladb combination table introns 10mm control}
# Render DataTable with enhancements
datatable(
  differential_pladb10mm_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```

#### PladB 1mM vs Control


```{r pladb combination table introns 1mm control}
# Render DataTable with enhancements
datatable(
  differential_pladb1mm_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

#### PladB 10mM vs 1mM


```{r pladb combination table introns 10mm 1mm}
# Render DataTable with enhancements
datatable(
  differential_pladb10mm_1mm_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```


#### Shared Introns in 10mM vs control & 1mM vs control

```{r pladb combination table introns shared}
# Render DataTable with enhancements
shared_introns_datatable<-pladb_pdiff_introns[pladb_pdiff_introns$EVENT %in% shared_introns,]
datatable(
  shared_introns_datatable,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```


## Alternative 5´ and 3´ Lists

### Calculations

```{r pdiff calculation alt}
pladb_pdiff_alt <- prepareTableVolcanoFDR(
  psitable = pladb_alt$PSI,
  qualtable = pladb_alt$Qual,
  npoints = 500,
  colsA = colsGroupA_pladb,
  colsB = colsGroupB_pladb,
  labA = groupA_pladb,
  labB = groupB_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000, 
  seed=TRUE, 
  CoverageWeight = FALSE) 

pladb_1mm_control_pdiff_alt <- prepareTableVolcanoFDR(
  psitable = pladb_alt$PSI,
  qualtable = pladb_alt$Qual,
  npoints = 500,
  colsA = colsGroupA_pladb,
  colsB = colsGroupC_pladb,
  labA = groupA_pladb,
  labB = groupC_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000, 
  seed=TRUE, 
  CoverageWeight = FALSE) 

pladb_1mm_10mm_pdiff_alt <- prepareTableVolcanoFDR(
  psitable = pladb_alt$PSI,
  qualtable = pladb_alt$Qual,
  npoints = 500,
  colsA = colsGroupC_pladb,
  colsB = colsGroupB_pladb,
  labA = groupC_pladb,
  labB = groupB_pladb,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000, 
  seed=TRUE, 
  CoverageWeight = FALSE) 


write.csv(pladb_pdiff_alt,"pladb_pdiff_alt.csv")
write.csv(pladb_1mm_control_pdiff_alt,"pladb_1mm_control_pdiff_alt.csv")
write.csv(pladb_1mm_10mm_pdiff_alt,"pladb_1mm_10mm_pdiff_alt.csv")
```


### FDR Volcano Plots { .tabset}

Volcano Plots of the FDR corrected exons for each study. In pink are the exons with a deltaPSI>=0.1.

#### PladB 10mM vs Control

```{r pladb fdr volcano alt 10mm control}
# INtersecting dhared alt between 10mm vs control and 1mm vs control
differential_pladb10mm_alt<-na.omit(pladb_pdiff_alt[pladb_pdiff_alt$FDR<=0.05 & abs(pladb_pdiff_alt$deltapsi) >= 0.1,])
differential_pladb1mm_alt<-na.omit(pladb_1mm_control_pdiff_alt[pladb_1mm_control_pdiff_alt$FDR<=0.05 & abs(pladb_1mm_control_pdiff_alt$deltapsi) >= 0.1,])

differential_pladb10mm_1mm_alt<-na.omit(pladb_1mm_10mm_pdiff_alt[pladb_1mm_10mm_pdiff_alt$FDR<=0.05 & abs(pladb_1mm_10mm_pdiff_alt$deltapsi) >= 0.1,])

shared_alt<-differential_pladb10mm_alt$EVENT[differential_pladb10mm_alt$EVENT %in% differential_pladb1mm_alt$EVENT]

# Volcano plot
library(ggrepel)
pladb_pdiff_alt<-na.omit(pladb_pdiff_alt)
# Add a Shared column based on the shared_alt
pladb_pdiff_alt$Shared <- ifelse(pladb_pdiff_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
pladb_pdiff_alt$Significant <- ifelse(
  pladb_pdiff_alt$FDR<=0.05 & pladb_pdiff_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_pdiff_alt$FDR<=0.05 & pladb_pdiff_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_pdiff_alt$negLogpvalue <- -log10(pladb_pdiff_alt$FDR)


max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_pdiff_alt <- pladb_pdiff_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_pdiff_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_pdiff_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_pdiff_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (10mM - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Alt 5´ 3´",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_alt_10mm_control.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

#### PladB 1mM vs Control

```{r pladb fdr volcano alt 1mm control}
pladb_1mm_control_pdiff_alt<-na.omit(pladb_1mm_control_pdiff_alt)
# Add a Shared column based on the shared_alt
pladb_1mm_control_pdiff_alt$Shared <- ifelse(pladb_1mm_control_pdiff_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
pladb_1mm_control_pdiff_alt$Significant <- ifelse(
  pladb_1mm_control_pdiff_alt$FDR<=0.05 & pladb_1mm_control_pdiff_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_1mm_control_pdiff_alt$FDR<=0.05 & pladb_1mm_control_pdiff_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_1mm_control_pdiff_alt$negLogpvalue <- -log10(pladb_1mm_control_pdiff_alt$FDR)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_1mm_control_pdiff_alt <- pladb_1mm_control_pdiff_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_1mm_control_pdiff_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_1mm_control_pdiff_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_1mm_control_pdiff_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (1mM - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Alt 5´ 3´",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_alt_1mm_control.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

#### PladB 10mM vs 1mM

```{r pladb fdr volcano alt 10mm 1mm}
pladb_1mm_10mm_pdiff_alt<-na.omit(pladb_1mm_10mm_pdiff_alt)
# Add a Shared column based on the shared_alt
pladb_1mm_10mm_pdiff_alt$Shared <- ifelse(pladb_1mm_10mm_pdiff_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
pladb_1mm_10mm_pdiff_alt$Significant <- ifelse(
  pladb_1mm_10mm_pdiff_alt$FDR<=0.05 & pladb_1mm_10mm_pdiff_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_1mm_10mm_pdiff_alt$FDR<=0.05 & pladb_1mm_10mm_pdiff_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_1mm_10mm_pdiff_alt$negLogpvalue <- -log10(pladb_1mm_10mm_pdiff_alt$FDR)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_1mm_10mm_pdiff_alt <- pladb_1mm_10mm_pdiff_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_1mm_10mm_pdiff_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_1mm_10mm_pdiff_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_1mm_10mm_pdiff_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (10mM - 1mM)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Alt 5´ 3´",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_alt_10mm_1mm.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot

```




### Individual Combination Tables { .tabset}

These tables show the alt that show a FDR<=0.1 in the pairwise comparison of each condition.


#### PladB 10mM vs control


```{r pladb combination table alt 10mm control}
# Render DataTable with enhancements
datatable(
  differential_pladb10mm_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```

#### PladB 1mM vs Control


```{r pladb combination table alt 1mm control}
# Render DataTable with enhancements
datatable(
  differential_pladb1mm_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

#### PladB 10mM vs 1mM


```{r pladb combination table alt 10mm 1mm}
# Render DataTable with enhancements
datatable(
  differential_pladb10mm_1mm_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```


#### Shared Alt in 10mM vs control & 1mM vs control

```{r pladb combination table alt shared}
# Render DataTable with enhancements
shared_alt_datatable<-pladb_pdiff_alt[pladb_pdiff_alt$EVENT %in% shared_alt,]
datatable(
  shared_alt_datatable,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```



# All Event Types Volcano Plots { .tabset}


## 10 mM vs Control

```{r 10mm control all volcano }

mega_volcano<-rbind(pladb_pdiff_exons,pladb_pdiff_introns,pladb_pdiff_alt)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (10mM - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_10mm_control_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)
ggsave("volcano_10mm_control_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 120)

volcano_plot
```


# Basic Stats on Found Events

## Events-level stats

```{r basic stats, fig.width=12, fig.height=6}

# Define study-specific data
pladb_exons_10 <- data.frame(EVENT = differential_pladb10mm_exons$EVENT, Type = "Exons", Study = "10mM vs Control")
pladb_exons_1 <- data.frame(EVENT = differential_pladb1mm_exons$EVENT, Type = "Exons", Study = "1mM vs Control")
pladb_exons_10_1 <- data.frame(EVENT = differential_pladb10mm_1mm_exons$EVENT, Type = "Exons", Study = "10mM vs 1mM")

pladb_introns_10 <- data.frame(EVENT = differential_pladb10mm_introns$EVENT, Type = "Introns", Study = "10mM vs Control")
pladb_introns_1 <- data.frame(EVENT = differential_pladb1mm_introns$EVENT, Type = "Introns", Study = "1mM vs Control")
pladb_introns_10_1 <- data.frame(EVENT = differential_pladb10mm_1mm_introns$EVENT, Type = "Introns", Study = "10mM vs 1mM")

pladb_alt_10 <- data.frame(EVENT = differential_pladb10mm_alt$EVENT, Type = "Alt", Study = "10mM vs Control")
pladb_alt_1 <- data.frame(EVENT = differential_pladb1mm_alt$EVENT, Type = "Alt", Study = "1mM vs Control")
pladb_alt_10_1 <- data.frame(EVENT = differential_pladb10mm_1mm_alt$EVENT, Type = "Alt", Study = "10mM vs 1mM")


# Combine all events into one dataframe
all_events <- bind_rows(pladb_exons_10, pladb_exons_1, pladb_exons_10_1, pladb_introns_10, pladb_introns_1, pladb_introns_10_1,pladb_alt_10, pladb_alt_1, pladb_alt_10_1)

# Determine the number of studies each event appears in
event_counts <- all_events %>%
  group_by(EVENT, Type) %>%
  summarize(Appearance_Count = n(), .groups = "drop") %>%
  mutate(Appearance = case_when(
    Appearance_Count == 3 ~ "All Three Studies",
    Appearance_Count == 2 ~ "Two Studies",
    TRUE ~ "Single Study"
  ))

# Merge back to the original dataset
all_events <- all_events %>%
  left_join(event_counts, by = c("EVENT", "Type"))

# Create the bar plot
p <- ggplot(all_events, aes(x = Study, fill = Appearance)) +
  geom_bar(position = "stack") +
  facet_wrap(~Type) +
  theme_minimal(base_size = 16, base_family = "sans") +
  scale_fill_manual(values = c(
    "All Three Studies" = "#117733",
    "Two Studies" = "#4E79A7",
    "Single Study" = "#F28E2B"
  )) +  # Nicer colors
  labs(
    title = "Comparison of Differentially Spliced Events in PladB",
    x = "Study",
    y = "Count of Events",
    fill = "Event Presence"
  ) +
  theme(
    legend.position = "top",
    strip.text = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    panel.grid = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save the plot
ggsave("stats_events_pladb.svg", p, width = 12, height = 6, units = "in", dpi = 300)

# Display the plot
print(p)


```

## Gene-level stats

```{r, basic gene stats, fig.width=12, fig.height=8}
# Define study-specific data
pladb_genes_10 <- data.frame(GENE = unique(c(differential_pladb10mm_exons$GENE,differential_pladb10mm_introns$GENE,differential_pladb10mm_alt$GENE)), Study = "10mM vs Control")
pladb_genes_1 <- data.frame(GENE = unique(c(differential_pladb1mm_exons$GENE,differential_pladb1mm_introns$GENE,differential_pladb1mm_alt$GENE)), Study = "1mM vs Control")
pladb_genes_10_1 <- data.frame(GENE = unique(c(differential_pladb10mm_1mm_exons$GENE,differential_pladb10mm_1mm_introns$GENE,differential_pladb10mm_1mm_alt$GENE)), Study = "10mM vs 1mM")
# Combine all genes into one dataframe
all_genes <- bind_rows(pladb_genes_10, pladb_genes_1,pladb_genes_10_1)

# Determine the number of studies each gene appears in
gene_counts <- all_genes %>%
  group_by(GENE) %>%
  summarize(Appearance_Count = n(), .groups = "drop") %>%
  mutate(Appearance = case_when(
    Appearance_Count == 3 ~ "All Three Studies",
    Appearance_Count == 2 ~ "Two Studies",
    TRUE ~ "Single Study"
  ))

# Merge back to the original dataset
all_genes <- all_genes %>%
  left_join(gene_counts, by = "GENE")

# Create the bar plot
p <- ggplot(all_genes, aes(x = Study, fill = Appearance)) +
  geom_bar(position = "stack") +
  theme_minimal(base_size = 16, base_family = "sans") +
  scale_fill_manual(values = c(
    "All Three Studies" = "#117733",
    "Two Studies" = "#4E79A7",
    "Single Study" = "#F28E2B"
  )) +  # Improved color scheme
  labs(
    title = "Comparison of Differentially Spliced Genes in PladB",
    x = "Study",
    y = "Count of Genes",
    fill = "Gene Presence"
  ) +
  theme(
    legend.position = "top",
    strip.text = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    panel.grid = element_blank(),  
    panel.background = element_blank(),  
    axis.line = element_line(color = "black")  
  )

# Save the plot
ggsave("stats_genes_pladb.svg", p, width = 12, height = 8, units = "in", dpi = 300)

# Display the plot
print(p)

```


# Enrichment Analysis with EnrichR { .tabset}

## Gene Ontology of all genes differentially spliced under any dose compared to control.

```{r pladb enrichr alt}
enrichdata<-enrichr(unique(c(differential_pladb10mm_exons$GENE,differential_pladb1mm_exons$GENE,differential_pladb10mm_introns$GENE,differential_pladb1mm_introns$GENE,differential_pladb10mm_alt$GENE,differential_pladb1mm_alt$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```

### GO Biological Process

```{r pladb bioprocessn alt, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[1]])
datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Cellular Component

```{r pladb cellcomponent alt, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[2]])
datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Molecular Function

```{r pladb molfunction alt, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[3]])
datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))

rna_genes<-enrichdata[[3]]$Genes[grepl("RNA Binding",enrichdata[[3]]$Term) & enrichdata[[3]]$P.value<=0.05]
# Separate rna_genes lis tinto separate names (they are separated by ";")
rna_genes<-unlist(strsplit(rna_genes,";"))
```

## PladB 10mM vs 1mM { .tabset}

```{r pladb enrichr 10mm 1mm}
enrichdata<-enrichr(unique(c(differential_pladb10mm_1mm_introns$GENE, differential_pladb10mm_1mm_exons$GENE,differential_pladb10mm_1mm_alt$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```

### GO Biological Process

```{r pladb bioprocess 10mm 1mm, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])
datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Cellular Component

```{r pladb cellcomponent 10mm 1mm, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])
datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Molecular Function

```{r pladb molfunction 10mm 1mm, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])
datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

# Gene-centric Analysis { .tabset}

The following analysis identifies the number of significant events a given gene has. This number of *hits* serves as a proxy of how heavily influenced by splicing a given gene has been. The table shows how many genes classified by the number of significant events I have found, alongside the proportion of ORF disruption for each group. The plot then shows the list of genes, with at least 3 *hits*, in the x-axis, their average |dPSI| in the y-axis, and the shape of the points shows whether that given event is ORF-disrupted.

## 10 mM vs Control

```{r gene-centric plot 10mm prep}
# Set seed for reproducibility
set.seed(44)

# -------------------------------
# 0. Read protein impact data and combine your events
# -------------------------------
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, 
                             fill = TRUE, quote = "")

# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_pladb10mm_exons,
  introns = differential_pladb10mm_introns,
  alt = differential_pladb10mm_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r 10mm gene-centric plot, fig.width=24, fig.height=10}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.6) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in PladB 10mM vs Control",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("10mm_control_splicing_events_plot.svg", plot = p2, width = 24, height = 10, dpi = 300)

# Display the plot
print(p2)
```


## 1 mM vs Control

```{r gene-centric plot 1mm prep}
# Set seed for reproducibility
set.seed(44)

# -------------------------------
# 0. Read protein impact data and combine your events
# -------------------------------
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, 
                             fill = TRUE, quote = "")

# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_pladb1mm_exons,
  introns = differential_pladb1mm_introns,
  alt = differential_pladb1mm_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r 1mm gene-centric plot, fig.width=24, fig.height=10}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.6) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in PladB 1mM vs Control",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("1mm_control_splicing_events_plot.svg", plot = p2, width = 24, height = 10, dpi = 300)

# Display the plot
print(p2)
```


## 10 mM vs 1mM

```{r gene-centric plot 10mm 1mm prep}
# Set seed for reproducibility
set.seed(44)

# -------------------------------
# 0. Read protein impact data and combine your events
# -------------------------------
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, 
                             fill = TRUE, quote = "")

# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_pladb10mm_1mm_exons,
  introns = differential_pladb10mm_1mm_introns,
  alt = differential_pladb10mm_1mm_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r 10mm 1mm gene-centric plot, fig.width=24, fig.height=10}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.6) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in PladB 10mM vs 1mM",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("10mm_1mm_control_splicing_events_plot.svg", plot = p2, width = 24, height = 10, dpi = 300)

# Display the plot
print(p2)
```




# Splicing Dynamics Heatmap PladB

Only Exons and Introns cassettes, not Alt. 

```{r heatmap prep 2, results='hide', fig.show='hide'}
set.seed(44)

# Extract all events
pladb_all <- filterEvents(
  pladb_events,
  types = c("C1", "C2", "C3", "S", "MIC", "IR","Alt3","Alt5"),
  N = 3
)

# Convert PSI values to a matrix and set row names
pladb_matrix <- pladb_all$PSI[, 7:15] %>%
  as.matrix()
rownames(pladb_matrix) <- pladb_all$PSI$EVENT

# Filter rows based on the final event lists and with abs(deltapsi)>=0.1
filtered_events <- unique(c(
  differential_pladb10mm_exons$EVENT[abs(differential_pladb10mm_exons$deltapsi)>=0.1],differential_pladb10mm_introns$EVENT[abs(differential_pladb10mm_introns$deltapsi)>=0.1],differential_pladb1mm_exons$EVENT[abs(differential_pladb1mm_exons$deltapsi)>=0.1],differential_pladb1mm_introns$EVENT[abs(differential_pladb1mm_introns$deltapsi)>=0.1]))

pladb_matrix <- pladb_matrix[rownames(pladb_matrix) %in% filtered_events, ]

# Arrange columns based on metadata
colnames(pladb_matrix)<-metadata_pladb$fastq_files
# Create a dendrogram for the columns
col_dend <- hclust(dist(t(pladb_matrix))) %>%
  as.dendrogram() %>%
  color_branches(k = 3) # Color branches with 3 clusters

# Check if row names contain "EX"
contains_EX <- grepl("EX", rownames(pladb_matrix))

# Define an improved color gradient for the heatmap
col_fun <- colorRamp2(
  c(0, 50, 100),
  c("purple", "white", "orange")
)

number_splices<-8



reference_table<-data.frame(EVENT=c(differential_pladb10mm_exons$EVENT,differential_pladb10mm_introns$EVENT,differential_pladb1mm_exons$EVENT,differential_pladb10mm_exons$EVENT,differential_pladb1mm_introns$EVENT,differential_pladb1mm_exons$EVENT,differential_pladb1mm_introns$EVENT), GENE=c(differential_pladb10mm_exons$GENE,differential_pladb10mm_introns$GENE,differential_pladb1mm_exons$GENE,differential_pladb10mm_exons$GENE,differential_pladb1mm_introns$GENE,differential_pladb1mm_exons$GENE,differential_pladb1mm_introns$GENE))



ht<-Heatmap(
  pladb_matrix, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns  = col_dend,
  column_title = "Oocytes PladB Samples at Different concentrations of PladB",
  row_title = "Splicing Events of |dPSI|>=0.1",
  column_names_rot = 45,
  column_labels = metadata_pladb$Description,
  column_dend_reorder = c(1:9),
  row_km = number_splices,
  row_dend_reorder = F,
  rect_gp = gpar(col = "white", lwd = 0.3),
  column_names_gp = gpar(fontsize = 16),
  show_row_names = FALSE,

)
ht = draw(ht); clustered_events<-row_order(ht)
text_list<-list()
# Loop through clustered events and assign dynamic names
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(pladb_matrix)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )

  # Assign the dynamic name and value
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}

protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")

events_for_impact<-rownames(pladb_matrix)

final_impact <- data.frame(EventID = rownames(pladb_matrix)) %>%  # Extract row names as EventID
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))  # Fill missing ONTO values with 0

# Define the left annotation (points) with axis labels
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),  # Adjusted width
    size = unit(4, "mm"),   # Adjusted size of points
    axis_param = list(
      side = "top",
      at = -2:2, # Numeric values to label
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45, # Rotation of labels
      gp = gpar(fontsize = 15) # Text style
    )
  )
)

# Define the right annotation (foo)
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)

```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot 2, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

ht <- Heatmap(
  pladb_matrix,
  name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_labels = metadata_pladb$Description,
  column_dend_reorder = c(1:9),
  row_km = number_splices,
  left_annotation = left_annotation,   # Add the points on the left
  right_annotation = right_annotation, # Add foo on the right
  row_dend_reorder = F,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"), # Adjust the gap size between rows
  column_gap = unit(4, "mm"), # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend horizontally
  )
)

# Draw the heatmap
ht <- draw(ht)

# Decorate the "foo" annotation slices (on the right)
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}


```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final 3}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- pladb_matrix[row_order, col_order]

final_impact_string<-protein_impact %>%
  dplyr::filter(EventID %in% events_for_impact) %>%
  slice(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-dplyr::select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))

# 

```


### Same Heatmap but averaging PSI values from same condition

```{r heatmap_plot short 2, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

pladb_matrix_short <- cbind(
  rowMeans(pladb_matrix[, 1:3]),
  rowMeans(pladb_matrix[, 4:6]),
  rowMeans(pladb_matrix[, 7:9])
)

# Convert to matrix and print result
colnames(pladb_matrix_short) <- c("Control", "PladB_1mM", "PladB_10mM")

pladb_matrix_short <- pladb_matrix_short[row_order,]

ht <- Heatmap(
  pladb_matrix_short,
  name = "PSI",
  col = col_fun,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:3),
  cluster_rows = FALSE,   # <-- This disables row clustering
  cluster_columns = FALSE, # Optionally disable column clustering if desired
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"),      # Adjust the gap size between rows
  left_annotation = left_annotation[row_order],   # Add the points on the left
  right_annotation = right_annotation[row_order],
  column_gap = unit(4, "mm"),   # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend vertically
  )
)

# Draw the heatmap
ht <- draw(ht)

# Draw the heatmap




```

```{r protein impact psi}

library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)      # For pairwise comparisons and p-value adjustment
library(ggpubr)       # For stat_pvalue_manual if needed

original_columns <- colnames(pladb_matrix)

# Prepare the data frame
pladb_df <- as.data.frame(pladb_matrix) %>% 
  rownames_to_column("EVENT") %>% 
  pivot_longer(
    cols = -EVENT,
    names_to = "sample",
    values_to = "value"
  ) 

# Modify dose based on sample name
pladb_df <- pladb_df %>%
  mutate(
    variable_order = match(sample, original_columns),
    group = ceiling(variable_order / 3),
    dose = case_when(
      str_detect(sample, "038|039|040") ~ "control",
      str_detect(sample, "041|042|043") ~ "1uM",
      str_detect(sample, "044|045|046") ~ "10uM",
      TRUE ~ NA_character_
    ),
    dose = factor(dose, levels = c("control", "1uM", "10uM"))  # Ensure correct order
  ) %>%
  select(-variable_order, -group)

# Assign the protein impact based on matching EventID.
pladb_df$protein_impact <- final_impact_string$ONTO[match(pladb_df$EVENT, final_impact_string$EventID)]

# Cluster the protein_impact values into desired groups
pladb_df <- pladb_df %>%
  mutate(
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disruption upon sequence inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disruption upon sequence exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ "Unknown"
    )
  ) %>%
  arrange(EVENT, sample, dose)

# Function to calculate bootstrap confidence intervals
bootstrap_ci <- function(values, n_bootstrap = 1000, conf_level = 0.95) {
  boot_samples <- replicate(n_bootstrap, mean(sample(values, replace = TRUE)))
  quantile(boot_samples, probs = c((1 - conf_level) / 2, 1 - (1 - conf_level) / 2))
}

# Perform pairwise paired t-tests within each protein_impact group
stat_test <- pladb_df %>%
  group_by(protein_impact) %>%
  pairwise_t_test(
    value ~ dose,
    paired = TRUE,
    p.adjust.method = "none"
  ) %>%
  ungroup() %>%
  filter(p.adj < 0.05) %>%
  mutate(signif = case_when(
    p.adj < 0.001 ~ "***",
    p.adj < 0.01  ~ "**",
    p.adj < 0.05  ~ "*"
  ))

# Compute summary statistics with bootstrapped confidence intervals
summary_df <- pladb_df %>%
  group_by(dose, protein_impact) %>%
  summarise(
    mean_value = mean(value),
    sd_value = sd(value),
    n = n(),
    ci_lower = bootstrap_ci(value)[1],
    ci_upper = bootstrap_ci(value)[2],
    .groups = "drop"
  )

# Ensure dose is a factor in stat_test
stat_test <- stat_test %>%
  mutate(
    group1 = factor(group1, levels = levels(pladb_df$dose)),
    group2 = factor(group2, levels = levels(pladb_df$dose)),
    y.position = max(pladb_df$value, na.rm = TRUE) * 1.05  # Adjusted dynamically
  )

# Set the upper y-axis limit dynamically
max_y <- max(pladb_df$value, na.rm = TRUE) * 1.1  

# Plot with refined settings
ggplot(summary_df, 
       aes(x = dose, y = mean_value, group = protein_impact, color = protein_impact, fill = protein_impact)) +
  geom_point(data = pladb_df, aes(x = dose, y = value), color = "grey70", alpha = 0.4, size = 1) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +
  
  # Add significance annotations
  stat_pvalue_manual(
    stat_test, 
    label = "signif",
    xmin = "group1", 
    xmax = "group2",
    y.position = "y.position",
    tip.length = 0.01,
    size = 4
  ) +

  # Facet by protein impact
  facet_wrap(~ protein_impact) +

  # Adjust x and y axes
  scale_y_continuous(limits = c(0, max_y), expand = expansion(mult = c(0.05, 0.05))) +

  # Clean and minimal theme
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major = element_line(color = "grey85", size = 0.3),
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 14),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(size = 12)
  ) +
  
  # Labels
  labs(x = "PladB Dose", 
       y = "Mean Value", 
       color = "Protein Impact", 
       fill = "Protein Impact")


```


### Enrichment of ORF Disrupted Genes { .tabset}

Note that interpretation should be done taking into account whether that specific ORF-disrupting events is being spliced in or out. This just may give an idea of the ontology of disrupted proteins.

```{r orf enrichr}
enrichdata<-enrichr(unique(reference_table$GENE[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]]), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))

orf_comparingcontrol_events<-unique(reference_table$EVENT[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]])
```

#### GO Biological Process

```{r orf bioprocess fmndko, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[1]])
datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r orf cellcomponent fmndko, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[2]])
datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r orf molfunction fmndko, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[3]])
datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```




# PladB 10mM vs Control UNIQUE (not shared with 1mM) events

```{r heatmap prep, results='hide', fig.show='hide'}
set.seed(44)


# Convert PSI values to a matrix and set row names
pladb_matrix <- pladb_all$PSI[, 7:15] %>%
  as.matrix()
rownames(pladb_matrix) <- pladb_all$PSI$EVENT


# Filter rows based on the final event lists and with abs(deltapsi)>=0.1
filtered_events <- unique(c(
  differential_pladb10mm_exons[!differential_pladb10mm_exons$EVENT %in% shared_exons,]$EVENT, differential_pladb10mm_introns[!differential_pladb10mm_introns$EVENT %in% shared_introns,]$EVENT))
pladb_matrix <- pladb_matrix[rownames(pladb_matrix) %in% filtered_events, ]

# Arrange columns based on metadata
colnames(pladb_matrix)<-metadata_pladb$fastq_files
# Create a dendrogram for the columns
col_dend <- hclust(dist(t(pladb_matrix))) %>%
  as.dendrogram() %>%
  color_branches(k = 3) # Color branches with 3 clusters

# Check if row names contain "EX"
contains_EX <- grepl("EX", rownames(pladb_matrix))

# Define an improved color gradient for the heatmap
col_fun <- colorRamp2(
  c(0, 50, 100),
  c("purple", "white", "orange")
)

number_splices<-5


reference_table<-data.frame(EVENT=c(differential_pladb10mm_exons$EVENT,differential_pladb10mm_introns$EVENT,differential_pladb1mm_exons$EVENT,differential_pladb1mm_introns$EVENT,differential_pladb10mm_1mm_introns$EVENT,differential_pladb10mm_1mm_exons$EVENT), GENE=c(differential_pladb10mm_exons$GENE,differential_pladb10mm_introns$GENE,differential_pladb1mm_exons$GENE,differential_pladb1mm_introns$GENE,differential_pladb10mm_1mm_introns$GENE,differential_pladb10mm_1mm_exons$GENE))



ht<-Heatmap(
  pladb_matrix, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns  = col_dend,
  column_title = "Oocytes PladB Samples at Different concentrations of PladB",
  row_title = "Splicing Events of |dPSI|>=0.1",
  column_names_rot = 45,
  column_labels = metadata_pladb$Description,
  column_dend_reorder = c(1:9),
  row_km = number_splices,
  row_dend_reorder = F,
  rect_gp = gpar(col = "white", lwd = 0.3),
  column_names_gp = gpar(fontsize = 16),
  show_row_names = FALSE,

)

ht = draw(ht); clustered_events<-row_order(ht)
text_list<-list()
# Loop through clustered events and assign dynamic names
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(pladb_matrix)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )

  # Assign the dynamic name and value
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}

protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")

events_for_impact<-rownames(pladb_matrix)

final_impact <- data.frame(EventID = rownames(pladb_matrix)) %>%  # Extract row names as EventID
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))  # Fill missing ONTO values with 0


# Define the left annotation (points) with axis labels
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),  # Adjusted width
    size = unit(4, "mm"),   # Adjusted size of points
    axis_param = list(
      side = "top",
      at = -2:2, # Numeric values to label
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45, # Rotation of labels
      gp = gpar(fontsize = 15) # Text style
    )
  )
)

# Define the right annotation (foo)
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)

```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Biological Process* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

ht <- Heatmap(
  pladb_matrix,
  name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_labels = metadata_pladb$Description,
  column_dend_reorder = c(1:9),
  row_km = number_splices,
  left_annotation = left_annotation,   # Add the points on the left
  right_annotation = right_annotation, # Add foo on the right
  row_dend_reorder = F,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"), # Adjust the gap size between rows
  column_gap = unit(4, "mm"), # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend horizontally
  )
)

# Draw the heatmap
ht <- draw(ht)

# Decorate the "foo" annotation slices (on the right)
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}


```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- pladb_matrix[row_order, col_order]

final_impact_string<-protein_impact %>%
  dplyr::filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-dplyr::select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))



```

### Enrichment of ORF Disrupted Genes { .tabset}

Note that interpretation should be done taking into account whether that specific ORF-disrupting events is being spliced in or out. This just may give an idea of the ontology of disrupted proteins.

```{r orf enrichr 2}
enrichdata<-enrichr(unique(reference_table$GENE[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]]), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))

orf_10mm_unique_exons<-differential_pladb10mm_exons[differential_pladb10mm_exons$EVENT %in% reference_table$EVENT[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]],]

orf_10mm_unique_introns<-differential_pladb10mm_introns[differential_pladb10mm_introns$EVENT %in% reference_table$EVENT[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]],]


```

#### GO Biological Process

```{r orf bioprocess 2, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[1]])
datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r orf cellcomponent 2, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[2]])
datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r orf molfunction 2, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[3]])
datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


# System Settings

```{r session info}
sessionInfo()
```


