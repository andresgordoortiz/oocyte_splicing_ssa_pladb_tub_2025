---
title: "Oocyte Alternative Splicing Analysis"
subtitle: "FMN2 & SPIRE1/2 KO"
author: "Andrés Gordo Ortiz @Al Jord Lab CRG"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: flatly
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    code_folding: hide
    code_download: false
    df_print: paged
    number_sections: true

editor_options:
  markdown:
    wrap: 72

header-includes:
  - '<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">'
  - '<style>
        /* Base styling */
        body {
          font-family: "Roboto", sans-serif;
          color: #333;
          background-color: #ffffff;
          margin: 0;
          padding: 20px;
        }
        .container {
          max-width: 960px;
          margin: auto;
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 {
          color: #2C3E50;
          text-align: center;
          font-weight: 700;
          margin: 0.5em 0;
        }
        h1 { font-size: 2.5em; }
        h2 { font-size: 2em; }
        h3 { font-size: 1.75em; }
        
        /* Text styling */
        p {
          line-height: 1.6;
          margin-bottom: 1em;
          text-align: justify;
        }
        .subtitle, .author, .date {
          text-align: center;
          color: #2C3E50;
          margin-bottom: 0.5em;
        }
        
        /* Links */
        a {
          color: #0275d8;
          text-decoration: none;
        }
        a:hover {
          text-decoration: underline;
        }
        
        /* Tables */
        table {
          width: 100%;
          border-collapse: collapse;
          margin: 20px 0;
        }
        th, td {
          border: 1px solid #ddd;
          padding: 10px;
        }
        th {
          background-color: #2C3E50;
          color: #fff;
        }
        tr:nth-child(even) {
          background-color: #f9f9f9;
        }
        tr:hover {
          background-color: #f1f1f1;
        }
     </style>'
---




```{r setup, include=FALSE}
# Ensure a clean environment and load required libraries.
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)


# Load required libraries
library("betAS")
library("ggplot2")
library("plotly")
library("dplyr")
library("tidyverse")
library("cowplot")
library("DT")
library("paletteer")
library("ggupset")
library("showtext")
library("ggtext")
library("readxl")
library("biomaRt")
library("patchwork")
library("org.Mm.eg.db")
library("org.Hs.eg.db")
library("enrichplot")
library("DOSE")
library("clusterProfiler")
library("ComplexHeatmap")
library("enrichR")
library("colorRamp2")
library("dendextend")
library("UpSetR")

# Register Google fonts
showtext_auto()
font_add_google("Roboto", "roboto")
font="roboto"

```

# Introduction to this Analysis

## Part 1: Upstream Analysis

The upstream analysis is performed on the CRG cluster using the Bash command line. This phase involves:

1. **Data Acquisition**:
  - Downloading `*.fastq.gz` files of these studies:
    - **FMN2 DKO Oocytes**
    - **SPIRE1/2 DKO Oocytes**
  - Merging technical replicates for superior sequencing depth. RNA Splicing analysis usually requires a minimum of 50 million reads per biological sample.

2. **Alignment**:
   - Aligning the sequences to the latest mouse genome release (mm10) using **Bowtie2** through the [Vast-Tools align function](https://link.springer.com/protocol/10.1007/978-1-0716-2521-7_7).

3. **Event Detection**:
   - Importing inclusion tables generated by Vast-Tools into RStudio. Vast-Tools does **not** find new splicing events, relaying on a manually curated database, [VASTDB](https://vastdb.crg.eu/), with more than 600.000 splicing events. The end result is an `Inclusion_table.tab`, which contains the splicing events as rows and the samples as columns. Splicing is quantified using the Percentage Spliced-In (PSI) parameter, which shows the percentage at which a given splicing event occurs across all sequencing reads of the gene. The database covers the following splicing events:
   
     - **Exons (EX)**: Cassette sequences that are either included or excluded in the mature mRNA.
     - **Introns (IN)**: Introns that are either retained or spliced out in the mature mRNA.
     - **Alternative 5' Splice Sites (Alt5)**: Exons that are spliced at different 5' sites (donor sites).
     - **Alternative 3' Splice Sites (Alt3)**: Exons that are spliced at different 3' sites (acceptor sites).
     - **Microexons (MIC)**: Exons that are shorter than 27 nucleotides.

---

## Part 2: Statistical Analysis

State-of-Art splicing analysis tools such as the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) employ a combination of statistical testing and simulations on the *beta* distribution to calculate the delta PSI (the difference in splicing between two conditions) and the False Discovery rate (FDR, or adjusted p-value) respectively. This is computationally demanding for such a large dataset. For that reason we focused first on analyzing *alternative* splicing events (that is, events with a PSI different that *0* or *100*--not always active, not always inactive) which constitute ~25% of all events in both *FMN2* and *Spire* studies. With that first analysis done (which can be accessed completely in the file `alternative_splicing_fmn2_spire.html`) we fine-tuned the code and used the complete dataset (using both constitutive and alternative events). Additionally, events with less than 10 supporting reads were filtered out (this is the minimum in the field, allowing for maximum sensibility). The specific steps taken for these analysis were.


1. **Statistical Testing**:
   - Use the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) in R to perform Beta Distribution simulations to obtain:
     - **False Discovery Rate (FDR)**
     - **delta Percentage Spliced-in (dPSI)**

2. **Filtering Criteria**: Significant events are defined by
     - FDR <= 0.05
     - |dPSI| >= 0.1 (out of 1. That is, at least a 10% increase or decrease in PSI)

All the code history can be accessed through its [GitHub Repository](https://github.com/andresgordoortiz/24crg_adel_manu_oocyte_splicing)

---


```{r inclusion tables}

fmndko_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/fmndko_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
fmndko_events <- filterEvents(getEvents(fmndko_data, tool = "vast-tools"), N = 10) # Extract alternative splicing events

fmndko_exons <- filterEvents(fmndko_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 10)
fmndko_introns <- filterEvents(fmndko_events, types = c("IR"), N = 10)
fmndko_alt <- filterEvents(fmndko_events, types = c("Alt5", "Alt3"), N = 10)



spire_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/spiredko_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
spire_events <- filterEvents(getEvents(spire_data, tool = "vast-tools"), N=10) # Extract alternative splicing events

spire_exons <- filterEvents(spire_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 10)
spire_introns <- filterEvents(spire_events, types = c("IR"), N = 10)
spire_alt <- filterEvents(spire_events, types = c("Alt5", "Alt3"), N = 10)


```


## Metadata { .tabset}

### FMN2DKO

```{r metadata fmn2dko}
# Load metadata file containing sample information
metadata_fmn2dko<-data.frame(samples=c("SRR6026682_SRR6026683_SRR6026684_merged","SRR6026685_SRR6026686_SRR6026687_merged","SRR6026688_SRR6026689_SRR6026690_merged","SRR6026691_SRR6026692_SRR6026693_merged"),condition=c("control","control","fmndko","fmndko"))
DT::datatable(metadata_fmn2dko, options = list(pageLength = nrow(metadata_fmn2dko), scrollX = TRUE))
```

### Spire

```{r metadata tao}
# Load metadata file containing sample information
metadata_spire<-data.frame(samples=c("Oocytes_FG_Spire12_Cont_a","Oocytes_FG_Spire12_Cont_b","Oocytes_FG_Spire12_Cont_c","Oocytes_FG_Spire12_DKO_a","Oocytes_FG_Spire12_DKO_b","Oocytes_FG_Spire12_DKO_c"), condition=rep(c("control", "spiredko"), each=3))
DT::datatable(metadata_spire, options = list(pageLength = nrow(metadata_spire), scrollX = TRUE))
```


---



# Total Splicing Events

This plot shows the total number of splicing events found during the **mapping**, alongside the proportions of each type of event. It is important to know that *vast-tools* does not find new events, but it identifies those manually curated in the database. The total number is the same for both datasets, as it is the total number of events registered and curated in ***VASTDB***, hence the *Complete Version.* 


```{r splicing events barplot stacked, fig.width=10, fig.height=6}

# Adjusted version of the script
splicing_events <- tibble(
  event_type = names(spire_events$EventsPerType),
  spire = spire_events$EventsPerType,
  fmndko = fmndko_events$EventsPerType
)

splicing_events_long <- splicing_events %>%
  pivot_longer(cols = c(spire, fmndko),
               names_to = "study", values_to = "count") %>%
  mutate(event_type = ifelse(event_type %in% c("C1", "C2", "C3", "ANN", "S", "MIC"), "EX", event_type)) %>%
  group_by(study, event_type) %>%
  summarize(count = sum(count, na.rm = TRUE), .groups = "drop")

# Proportion bar plot
plot_proportion <- ggplot(splicing_events_long, aes(fill = event_type, y = count, x = study)) +
  geom_bar(position = "fill", stat = "identity") +
  labs(
    title = "<b style='font-size:18px;'>Proportion of Splicing Events by Study</b>",
    x = NULL,
    y = "Proportion of Events",
    fill = "Event Type"
  ) +
  theme_minimal(base_family = font) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    plot.title = element_markdown(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5)
  ) +
  scale_fill_paletteer_d("MetBrewer::Hokusai3")

splicing_events_long_sum<-splicing_events_long %>%
  dplyr::group_by(study) %>%
  summarize(count = sum(count))


# Absolute counts plot
plot_absolute <- ggplot(splicing_events_long_sum, aes(y = count, x = study)) +
  geom_point(color = "#C70039", size = 3) +
  geom_text(aes(label = count), vjust = -1, size = 4, check_overlap = TRUE) +
  labs(
    x = "Study",
    y = "Number of Events",
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal(base_family = font) +
  theme(
    legend.position = "none",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text( size=15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3)
  ) +
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.2)))


# Combine plots
combined_plot <- plot_proportion / plot_absolute +
  plot_layout(heights = c(1, 0.5)) &
  theme(plot.margin = margin(5,5, 0, 5))

ggsave("events_mapped.svg", plot = combined_plot, width = 10, height = 6, units = "in", dpi = 300)

# Display combined plot
combined_plot
```

```{r general stats}
vastdb_events<-read.table("EVENT_INFO-mm10.tab", header = TRUE, sep = "\t")
bin_exons <- function(n) {
  if (is.na(n)) return(NA) # Handle missing values
  else if (n < 6) return("1-5")
  else if (n < 9) return("6-10")
  else if (n < 21) return("11-20")
  else return("21+")
}

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_exons<-vastdb_events[grep("EX", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$exon_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_exons<-apply_bin_exons(vastdb_exons)

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_introns<-vastdb_events[grep("IN", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$intron_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_introns<-apply_bin_exons(vastdb_introns)

exons_per_gene<-read.table("coding_unique_exon_counts_per_gene.txt")
colnames(exons_per_gene)<-c("gene","exons")



len_genes<-read.table("gene_avg_exons.txt", header = T)
len_genes$GENE_ID<-gsub("\\..*","",len_genes$GENE_ID)
len_genes_with_introns<-read.table("gene_avg_introns_exons.txt", header = T)
len_genes_with_introns$GENE_ID<-gsub("\\..*","",len_genes_with_introns$GENE_ID)

```

# Inclusion or Exclusion Plots { .tabset}

These plots show the distribution of the splicing change (dPSI) comparing the KO mutant vs the control. If there is a tendency towards inclusion or exclusion, the bell-shaped curve will be shifted to the right or left, respectively. First, I calculated the mean of each event per condition and then I calculated the difference between means for each event. The subtitle shows the Wilcoxon test assessing this possible asymmetry. The area under the curve for both sides (>0 and <0) is shown numerically. Only events with a dPSI greater or lower than 0 are shown for clarity.

## Exons 

### Spire

```{r inclusionumber of exons spire, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------
# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
spire_exons_df <- spire_exons$PSI %>% 
  filter(complete.cases(select(., 7:12)))

# Compute the averages and PSI difference for each row
spire_exons_df <- spire_exons_df %>% 
  mutate(
    avg_KO = rowMeans(select(., 10:12)),
    avg_control = rowMeans(select(., 7:9)),
    difference = avg_KO - avg_control
  ) %>% 
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(spire_exons_df) > 5000) {
  shapiro_sample <- sample(spire_exons_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(spire_exons_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(spire_exons_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(spire_exons_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(spire_exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(spire_exons_df$difference > 0) * 100, 1)
n_samples <- nrow(spire_exons_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  spire_exons_df[abs(spire_exons_df$difference) > 0, ], 
  aes(x = difference)
) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0), 
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Exons in Spire",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (KO - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Assign colors explicitly to match annotations
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 5, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 5, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/spire_exons_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)
```

```{r skewness spire}
# Connect to Ensembl BioMart for mouse
ensembl <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

# Retrieve gene symbols
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters = "mgi_symbol",
  values = spire_exons_df$GENE,
  mart = ensembl
)

# Merge gene symbols and exon counts
spire_exons_df_number <- spire_exons_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id), by = c("GENE" = "mgi_symbol")) %>%
  left_join(exons_per_gene %>% select(gene, exons), by = c("ensembl_gene_id" = "gene")) %>%
  rename(numb_exons = exons)


library(dplyr)
library(ggplot2)
library(purrr)

set.seed(123)

# 1. Manual skewness
skewness_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

# 2. Bin the data
binned <- spire_exons_df_number %>%
  filter(abs(difference) > 0, !is.na(numb_exons)) %>%
  mutate(
    exon_bin = cut(numb_exons,
                   breaks = c(0, 10, 50, Inf),
                   labels = c("1–10", "11–50", "51+"),
                   right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Bootstrap skewness per bin
boot_results <- binned %>%
  group_by(exon_bin) %>%
  summarise(
    boot_skews = list(replicate(
      1000,
      skewness_manual(sample(difference, replace = TRUE))
    )),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )


# 1. Compute per‐bin stats including manual skewness
skew_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

bin_stats <- spire_exons_df_number %>%
  filter(abs(difference) > 0) %>%
  mutate(
    exon_bin = cut(numb_exons, breaks = c(0,10,50,Inf),
                   labels = c("1–10","11–50","51+"), right = TRUE)
  ) %>%
  filter(!is.na(exon_bin)) %>%
  group_by(exon_bin) %>%
  summarise(
    sample_vec = list(if(n() > 5000) sample(difference,5000) else difference),
    n = n(),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    skewness = skew_manual(sample_vec),
    shapiro_p = shapiro.test(sample_vec)$p.value,
    test_used = if(shapiro_p > .05) "t-test" else "Wilcoxon",
    test_p   = if(test_used=="t-test") t.test(sample_vec,mu=0)$p.value
               else wilcox.test(sample_vec,mu=0)$p.value,
    pct_below = mean(sample_vec < 0)*100,
    pct_above = mean(sample_vec > 0)*100
  ) %>%
  select(exon_bin, n, skewness, test_used, test_p, pct_below, pct_above)



library(ggplot2)
library(dplyr)

# Make sure your font is available:

library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)

font_add_google(name = "Courier Prime", family = "Courier Prime") 
library(showtext)
showtext_auto()

boot_long <- boot_results %>%
  mutate(exon_bin = factor(exon_bin,
                           levels = c("1–10", "11–50", "51+"))) %>%
  unnest(boot_skews)

p <- ggplot(boot_results,
            aes(x = exon_bin, y = skew_estimate)) +
  
  # jittered bootstraps
  geom_jitter(data = boot_long,
              aes(fill = exon_bin, y = boot_skews),
              position = position_jitter(width = 0.15, height = 0),
              shape = 21,
              color = "gray30", 
              size = 2,
              alpha = 0.05,
              stroke = 0.8) +

  # polynomial regression (2nd degree)
  geom_smooth(data = boot_long,
              aes(x = as.numeric(exon_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x, 2),
              se = FALSE,
              linetype = "dashed",
              color = "grey40",    # grey line
              size = 1.5) +        # thicker

  # main points
  geom_point(aes(fill = exon_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +

  scale_fill_manual(values = c(
    "1–10"  = "#d1cbe5",
    "11–50" = "#9671bd",
    "51+"   = "#6a408d"
  ), name = "Exon Bin",
     guide = guide_legend(override.aes = list(shape = 21, 
                                             alpha = 1,
                                             size = 4,
                                             color = "gray30"))) +
            

  # significance aesthetics
  scale_color_manual(values = c(`TRUE`  = "#378d94",
                                `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +

  # densify grid on y-axis
  scale_y_continuous(
    breaks = pretty_breaks(n = 5),         # fewer major
    minor_breaks = waiver(),               # you can specify seq(min, max, length.out) here
    expand = expansion(add = 0.1)
  ) +

  # densify grid on x-axis
  scale_x_discrete(expand = expansion(add = 0.5)) +

  # labels
  labs(
    title = "Bootstrapped Skewness of Spire KO Splicing",
    x     = "Number of exons per gene",
    y     = "Skewness of ΔPSI Distribution"
  ) +

  # theme tweaks
  # theme tweaks
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",

    # Remove grid lines, but keep the square
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),

    # add a border around the panel
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),

    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10),
  ) +

  # Add a grey line at y = 0
  geom_hline(yintercept = 0, color = "grey50", linetype = "solid", size = 0.5)

print(p)


ggsave("spire_exons.svg",
       plot   = p,
       width  = 6,
       height = 6)

```

```{r skewness len spire}
library(biomaRt)
library(dplyr)
library(purrr)
library(ggplot2)
library(tidyr)
library(scales)
library(showtext)

# Connect to Ensembl & get gene IDs as before
ensembl <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters    = "mgi_symbol",
  values     = spire_exons_df$GENE,
  mart       = ensembl
)

# Join in AVG_TRANSCRIPT_LENGTH
spire_exons_df_len <- spire_exons_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id),
            by = c("GENE" = "mgi_symbol")) %>%
  left_join(len_genes %>% select(GENE_ID, AVG_TRANSCRIPT_LENGTH),
            by = c("ensembl_gene_id" = "GENE_ID")) %>%
  rename(transcript_len = AVG_TRANSCRIPT_LENGTH)

# Prepare data: filter out NAs and zero‐difference
data_len <- spire_exons_df_len %>%
  filter(abs(difference) > 0, !is.na(transcript_len))

# Define length‐based bins at tertiles
breaks_len <- quantile(data_len$transcript_len,
                       probs = c(0, 1/3, 2/3, 1),
                       na.rm = TRUE)
labels_len <- c("Short", "Medium", "Long")

binned_len <- data_len %>%
  mutate(
    len_bin = cut(transcript_len,
                  breaks = breaks_len,
                  labels = labels_len,
                  include.lowest = TRUE,
                  right = TRUE)
  ) %>%
  filter(!is.na(len_bin))

# Manual skewness function
skewness_manual <- function(x) {
  x <- na.omit(x)
  if (length(x) < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / length(x) / (s^3)
}

set.seed(123)
# Bootstrap per bin
boot_len <- binned_len %>%
  group_by(len_bin) %>%
  summarise(
    boot_skews = list(
      replicate(1000,
                skewness_manual(
                  sample(difference, replace = TRUE)
                )
      )
    ),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )

# Expand for plotting
boot_long_len <- boot_len %>%
  unnest(boot_skews)

# Plot
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()

ggplot(boot_len, aes(x = len_bin, y = skew_estimate)) +
  geom_jitter(data = boot_long_len,
              aes(y = boot_skews, fill = len_bin),
              position = position_jitter(width = 0.15),
              shape = 21, color = "gray30",
              size = 2, alpha = 0.05, stroke = 0.8) +
  geom_smooth(data = boot_long_len,
              aes(x = as.numeric(len_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x,2),
              se = FALSE, linetype = "dashed", color = "grey40", size = 1.2) +
  geom_point(aes(fill = len_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +
  scale_fill_manual(values = c(
    Short  = "#d1cbe5",
    Medium = "#9671bd",
    Long   = "#6a408d"
  ), name = "Transcript‑Length Bin") +
  scale_color_manual(values = c(`TRUE` = "#378d94", `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +
  scale_y_continuous(breaks = pretty_breaks(5), expand = expansion(add = 0.1)) +
  scale_x_discrete(expand = expansion(add = 0.5)) +
  geom_hline(yintercept = 0, color = "grey50") +
  labs(
    title = "Bootstrapped Skewness of ΔPSI by Transcript‑Length Bin",
    x     = "Average Transcript Length Bin",
    y     = "Skewness of ΔPSI"
  ) +
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),
    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10)
  )

# Save
ggsave("spire_exons_length_bins.svg", width = 6, height = 6)


```


### FMN2

```{r inclusionumber of exons fmndko, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------

# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
fmndko_exons_df <- fmndko_exons$PSI %>% 
  filter(complete.cases(select(., 7:10)))

# Compute the averages and PSI difference for each row
fmndko_exons_df <- fmndko_exons_df %>% 
  mutate(
    avg_KO = rowMeans(select(., 9:10)),
    avg_control = rowMeans(select(., 7:8)),
    difference = avg_KO - avg_control
  ) %>% 
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(fmndko_exons_df) > 5000) {
  shapiro_sample <- sample(fmndko_exons_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(fmndko_exons_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(fmndko_exons_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(fmndko_exons_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(fmndko_exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(fmndko_exons_df$difference > 0) * 100, 1)
n_samples <- nrow(fmndko_exons_df)

# ---- Plot -------------------------------------------------------------------
# Optionally, filter out zero differences if they are considered ambiguous
plot_data <- fmndko_exons_df

plot_psi_distribution <- ggplot(plot_data, aes(x = difference)) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0), 
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Exons in FMN2",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (KO - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = seq(-100, 100, by = 25)
  ) +
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),  # Blue for dPSI < 0, Red for dPSI > 0
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  annotate("label", x = -65, y = 0.1, hjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 7, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/fmn2_exons_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)
print(plot_psi_distribution)


```

```{r skewness fmn2}


# Retrieve gene symbols
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters = "mgi_symbol",
  values = fmndko_exons_df$GENE,
  mart = ensembl
)

# Merge gene symbols and exon counts
fmndko_exons_df <- fmndko_exons_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id), by = c("GENE" = "mgi_symbol")) %>%
  left_join(exons_per_gene %>% select(gene, exons), by = c("ensembl_gene_id" = "gene")) %>%
  rename(numb_exons = exons)


library(dplyr)
library(ggplot2)
library(purrr)

set.seed(123)

# 1. Manual skewness
skewness_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

# 2. Bin the data
binned <- fmndko_exons_df %>%
  filter(abs(difference) > 0, !is.na(numb_exons)) %>%
  mutate(
    exon_bin = cut(numb_exons,
                   breaks = c(0, 10, 50, Inf),
                   labels = c("1–10", "11–50", "51+"),
                   right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Bootstrap skewness per bin
boot_results <- binned %>%
  group_by(exon_bin) %>%
  summarise(
    boot_skews = list(replicate(
      1000,
      skewness_manual(sample(difference, replace = TRUE))
    )),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )


library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)

font_add_google(name = "Courier Prime", family = "Courier Prime") 
library(showtext)
showtext_auto()

boot_long <- boot_results %>%
  mutate(exon_bin = factor(exon_bin,
                           levels = c("1–10", "11–50", "51+"))) %>%
  unnest(boot_skews)

p <- ggplot(boot_results,
            aes(x = exon_bin, y = skew_estimate)) +
  
  # jittered bootstraps
  geom_jitter(data = boot_long,
              aes(fill = exon_bin, y = boot_skews),
              position = position_jitter(width = 0.15, height = 0),
              shape = 21,
              color = "gray30", 
              size = 2,
              alpha = 0.05,
              stroke = 0.8) +

  # polynomial regression (2nd degree)
  geom_smooth(data = boot_long,
              aes(x = as.numeric(exon_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x, 2),
              se = FALSE,
              linetype = "dashed",
              color = "grey40",    # grey line
              size = 1.5) +        # thicker

  # main points
  geom_point(aes(fill = exon_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +

  scale_fill_manual(values = c(
    "1–10"  = "#d1cbe5",
    "11–50" = "#9671bd",
    "51+"   = "#6a408d"
  ), name = "Exon Bin",
     guide = guide_legend(override.aes = list(shape = 21, 
                                             alpha = 1,
                                             size = 4,
                                             color = "gray30"))) +
            

  # significance aesthetics
  scale_color_manual(values = c(`TRUE`  = "#378d94",
                                `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +

  # densify grid on y-axis
  scale_y_continuous(
    breaks = pretty_breaks(n = 5),         # fewer major
    minor_breaks = waiver(),               # you can specify seq(min, max, length.out) here
    expand = expansion(add = 0.1)
  ) +

  # densify grid on x-axis
  scale_x_discrete(expand = expansion(add = 0.5)) +

  # labels
  labs(
    title = "Bootstrapped Skewness of FMN2 KO Splicing",
    x     = "Number of exons per gene",
    y     = "Skewness of ΔPSI Distribution"
  ) +

  # theme tweaks
  # theme tweaks
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",

    # Remove grid lines, but keep the square
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),

    # add a border around the panel
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),

    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10),
  ) +

  # Add a grey line at y = 0
  geom_hline(yintercept = 0, color = "grey50", linetype = "solid", size = 0.5)

print(p)


ggsave("fmn2_exons.svg",
       width  = 6,
       height = 6)

```

```{r skewness len fmn}
library(biomaRt)
library(dplyr)
library(purrr)
library(ggplot2)
library(tidyr)
library(scales)
library(showtext)

# Connect to Ensembl & get gene IDs as before
ensembl <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters    = "mgi_symbol",
  values     = fmndko_exons_df$GENE,
  mart       = ensembl
)

# Join in AVG_TRANSCRIPT_LENGTH
fmndko_exons_df_len <- fmndko_exons_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id),
            by = c("GENE" = "mgi_symbol")) %>%
  left_join(len_genes %>% select(GENE_ID, AVG_TRANSCRIPT_LENGTH),
            by = c("ensembl_gene_id" = "GENE_ID")) %>%
  rename(transcript_len = AVG_TRANSCRIPT_LENGTH)

# Prepare data: filter out NAs and zero‐difference
data_len <- fmndko_exons_df_len %>%
  filter(abs(difference) > 0, !is.na(transcript_len))

# Define length‐based bins at tertiles
breaks_len <- quantile(data_len$transcript_len,
                       probs = c(0, 1/3, 2/3, 1),
                       na.rm = TRUE)
labels_len <- c("Short", "Medium", "Long")

binned_len <- data_len %>%
  mutate(
    len_bin = cut(transcript_len,
                  breaks = breaks_len,
                  labels = labels_len,
                  include.lowest = TRUE,
                  right = TRUE)
  ) %>%
  filter(!is.na(len_bin))

# Manual skewness function
skewness_manual <- function(x) {
  x <- na.omit(x)
  if (length(x) < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / length(x) / (s^3)
}

set.seed(123)
# Bootstrap per bin
boot_len <- binned_len %>%
  group_by(len_bin) %>%
  summarise(
    boot_skews = list(
      replicate(1000,
                skewness_manual(
                  sample(difference, replace = TRUE)
                )
      )
    ),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )

# Expand for plotting
boot_long_len <- boot_len %>%
  unnest(boot_skews)

# Plot
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()

ggplot(boot_len, aes(x = len_bin, y = skew_estimate)) +
  geom_jitter(data = boot_long_len,
              aes(y = boot_skews, fill = len_bin),
              position = position_jitter(width = 0.15),
              shape = 21, color = "gray30",
              size = 2, alpha = 0.05, stroke = 0.8) +
  geom_smooth(data = boot_long_len,
              aes(x = as.numeric(len_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x,2),
              se = FALSE, linetype = "dashed", color = "grey40", size = 1.2) +
  geom_point(aes(fill = len_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +
  scale_fill_manual(values = c(
    Short  = "#d1cbe5",
    Medium = "#9671bd",
    Long   = "#6a408d"
  ), name = "Transcript‑Length Bin") +
  scale_color_manual(values = c(`TRUE` = "#378d94", `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +
  scale_y_continuous(breaks = pretty_breaks(5), expand = expansion(add = 0.1)) +
  scale_x_discrete(expand = expansion(add = 0.5)) +
  geom_hline(yintercept = 0, color = "grey50") +
  labs(
    title = "Bootstrapped Skewness of ΔPSI by Transcript‑Length Bin",
    x     = "Average Transcript Length Bin",
    y     = "Skewness of ΔPSI"
  ) +
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),
    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10)
  )

# Save
ggsave("fmndko_exons_length_bins.svg", width = 6, height = 6)

```

## Introns

### Spire

```{r inclusionumber of introns spire, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------
# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
spire_introns_df <- spire_introns$PSI %>% 
  filter(complete.cases(select(., 7:12)))

# Compute the averages and PSI difference for each row
spire_introns_df <- spire_introns_df %>% 
  mutate(
    avg_KO = rowMeans(select(., 10:12)),
    avg_control = rowMeans(select(., 7:9)),
    difference = avg_KO - avg_control
  ) %>% 
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(spire_introns_df) > 5000) {
  shapiro_sample <- sample(spire_introns_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(spire_introns_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(spire_introns_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(spire_introns_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(spire_introns_df$difference < 0) * 100, 1)
pct_above <- round(mean(spire_introns_df$difference > 0) * 100, 1)
n_samples <- nrow(spire_introns_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  spire_introns_df[abs(spire_introns_df$difference) > 0, ], 
  aes(x = difference)
) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0), 
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Introns in Spire",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (KO - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Assign colors explicitly to match annotations
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 5, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 5, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/spire_introns_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)
```

```{r skewness spire}

# Connect to Ensembl BioMart for mouse

# Retrieve gene symbols
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters = "mgi_symbol",
  values = spire_introns_df$GENE,
  mart = ensembl
)

# Merge gene symbols and intron counts
spire_introns_df <- spire_introns_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id), by = c("GENE" = "mgi_symbol")) %>%
  left_join(exons_per_gene %>% select(gene, exons), by = c("ensembl_gene_id" = "gene")) %>%
  rename(numb_exons = exons)


library(dplyr)
library(ggplot2)
library(purrr)

set.seed(123)

# 1. Manual skewness
skewness_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

# 2. Bin the data
binned <- spire_introns_df %>%
  filter(abs(difference) > 0, !is.na(numb_exons)) %>%
  mutate(
    exon_bin = cut(numb_exons,
                   breaks = c(0, 10, 50, Inf),
                   labels = c("1–10", "11–50", "51+"),
                   right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Bootstrap skewness per bin
boot_results <- binned %>%
  group_by(exon_bin) %>%
  summarise(
    boot_skews = list(replicate(
      1000,
      skewness_manual(sample(difference, replace = TRUE))
    )),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )

# 4. Plot with significance highlighting
ggplot(boot_results, aes(x = exon_bin, y = skew_estimate)) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                width = 0.2, color = "gray40") +
  geom_point(aes(color = significant, shape = significant), size = 4) +
  scale_color_manual(
    values = c(`TRUE` = "firebrick", `FALSE` = "steelblue"),
    guide = guide_legend(title = "Significant\nskew?" )
  ) +
  scale_shape_manual(
    values = c(`TRUE` = 17, `FALSE` = 16),
    guide = guide_legend(title = "Significant\nskew?" )
  ) +
  labs(
    title = "Bootstrapped Skewness of ΔPSI by Exon-Count Bin",
    x = "Number of introns per gene (binned)",
    y = "Skewness of ΔPSI (with 95% CI)"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")



# 1. Compute per‐bin stats including manual skewness
skew_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

bin_stats <- spire_introns_df %>%
  filter(abs(difference) > 0) %>%
  mutate(
    exon_bin = cut(numb_exons, breaks = c(0,10,50,Inf),
                   labels = c("1–10","11–50","51+"), right = TRUE)
  ) %>%
  filter(!is.na(exon_bin)) %>%
  group_by(exon_bin) %>%
  summarise(
    sample_vec = list(if(n() > 5000) sample(difference,5000) else difference),
    n = n(),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    skewness = skew_manual(sample_vec),
    shapiro_p = shapiro.test(sample_vec)$p.value,
    test_used = if(shapiro_p > .05) "t-test" else "Wilcoxon",
    test_p   = if(test_used=="t-test") t.test(sample_vec,mu=0)$p.value
               else wilcox.test(sample_vec,mu=0)$p.value,
    pct_below = mean(sample_vec < 0)*100,
    pct_above = mean(sample_vec > 0)*100
  ) %>%
  select(exon_bin, n, skewness, test_used, test_p, pct_below, pct_above)

# 2. Prepare plotting data
plot_df <- spire_introns_df %>%
  filter(abs(difference) > 0) %>%
  mutate(
    exon_bin = cut(numb_exons, breaks = c(0,10,50,Inf),
                   labels = c("1–10","11–50","51+"), right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Plot with skewness annotation
numbintrons_plot<-ggplot(plot_df, aes(x = difference)) +
  geom_histogram(aes(y = ..density.., fill = difference > 0),
                 bins = 50, alpha = 0.8, color = "black") +
  scale_fill_manual(values = c("#4BA3C3","#D62839")) +
  facet_wrap(~ exon_bin, scales = "free_y") +
  theme_classic() +
  theme(strip.text = element_text(face="bold")) +
  labs(x = expression(Delta*"PSI"), y = "Density") +
  geom_text(
    data = bin_stats,
    aes(
      x = Inf, y = Inf,
      label = sprintf(
        "Skewness = %.2f\n%s p=%.3g\nn=%d",
        skewness, test_used, test_p, n
      )
    ),
    hjust = 1.05, vjust = 1.05, size = 3.5
  )
print(numbintrons_plot)


library(ggplot2)
library(dplyr)

# Make sure your font is available:

library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)

font_add_google(name = "Courier Prime", family = "Courier Prime") 
library(showtext)
showtext_auto()

boot_long <- boot_results %>%
  mutate(exon_bin = factor(exon_bin,
                           levels = c("1–10", "11–50", "51+"))) %>%
  unnest(boot_skews)

p <- ggplot(boot_results,
            aes(x = exon_bin, y = skew_estimate)) +
  
  # jittered bootstraps
  geom_jitter(data = boot_long,
              aes(fill = exon_bin, y = boot_skews),
              position = position_jitter(width = 0.15, height = 0),
              shape = 21,
              color = "gray30", 
              size = 2,
              alpha = 0.05,
              stroke = 0.8) +

  # polynomial regression (2nd degree)
  geom_smooth(data = boot_long,
              aes(x = as.numeric(exon_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x, 2),
              se = FALSE,
              linetype = "dashed",
              color = "grey40",    # grey line
              size = 1.5) +        # thicker

  # main points
  geom_point(aes(fill = exon_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +

  scale_fill_manual(values = c(
    "1–10"  = "#d1cbe5",
    "11–50" = "#9671bd",
    "51+"   = "#6a408d"
  ), name = "Intron Bin",
     guide = guide_legend(override.aes = list(shape = 21, 
                                             alpha = 1,
                                             size = 4,
                                             color = "gray30"))) +
            

  # significance aesthetics
  scale_color_manual(values = c(`TRUE`  = "#378d94",
                                `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +

  # densify grid on y-axis
  scale_y_continuous(
    breaks = pretty_breaks(n = 5),         # fewer major
    minor_breaks = waiver(),               # you can specify seq(min, max, length.out) here
    expand = expansion(add = 0.1)
  ) +

  # densify grid on x-axis
  scale_x_discrete(expand = expansion(add = 0.5)) +

  # labels
  labs(
    title = "Bootstrapped Skewness of Spire KO Splicing",
    x     = "Number of introns per gene",
    y     = "Skewness of ΔPSI Distribution"
  ) +

  # theme tweaks
  # theme tweaks
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",

    # Remove grid lines, but keep the square
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),

    # add a border around the panel
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),

    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10),
  ) +

  # Add a grey line at y = 0
  geom_hline(yintercept = 0, color = "grey50", linetype = "solid", size = 0.5)

print(p)


ggsave("spire_introns.svg",
       plot   = p,
       width  = 6,
       height = 6)

```



### FMN2

```{r inclusionumber of introns fmndko, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------

# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
fmndko_introns_df <- fmndko_introns$PSI %>% 
  filter(complete.cases(select(., 7:10)))

# Compute the averages and PSI difference for each row
fmndko_introns_df <- fmndko_introns_df %>% 
  mutate(
    avg_KO = rowMeans(select(., 9:10)),
    avg_control = rowMeans(select(., 7:8)),
    difference = avg_KO - avg_control
  ) %>% 
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(fmndko_introns_df) > 5000) {
  shapiro_sample <- sample(fmndko_introns_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(fmndko_introns_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(fmndko_introns_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(fmndko_introns_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(fmndko_introns_df$difference < 0) * 100, 1)
pct_above <- round(mean(fmndko_introns_df$difference > 0) * 100, 1)
n_samples <- nrow(fmndko_introns_df)

# ---- Plot -------------------------------------------------------------------
# Optionally, filter out zero differences if they are considered ambiguous
plot_data <- fmndko_introns_df

plot_psi_distribution <- ggplot(plot_data, aes(x = difference)) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0), 
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Introns in FMN2",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (KO - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = seq(-100, 100, by = 25)
  ) +
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),  # Blue for dPSI < 0, Red for dPSI > 0
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  annotate("label", x = -65, y = 0.1, hjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 7, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/fmn2_introns_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)
print(plot_psi_distribution)


```

```{r skewness fmn2}


# Retrieve gene symbols
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters = "mgi_symbol",
  values = fmndko_introns_df$GENE,
  mart = ensembl
)

# Merge gene symbols and intron counts
fmndko_introns_df <- fmndko_introns_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id), by = c("GENE" = "mgi_symbol")) %>%
  left_join(exons_per_gene %>% select(gene, exons), by = c("ensembl_gene_id" = "gene")) %>%
  rename(numb_exons = exons)


library(dplyr)
library(ggplot2)
library(purrr)

set.seed(123)

# 1. Manual skewness
skewness_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

# 2. Bin the data
binned <- fmndko_introns_df %>%
  filter(abs(difference) > 0, !is.na(numb_exons)) %>%
  mutate(
    exon_bin = cut(numb_exons,
                   breaks = c(0, 10, 50, Inf),
                   labels = c("1–10", "11–50", "51+"),
                   right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Bootstrap skewness per bin
boot_results <- binned %>%
  group_by(exon_bin) %>%
  summarise(
    boot_skews = list(replicate(
      1000,
      skewness_manual(sample(difference, replace = TRUE))
    )),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )


library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)

font_add_google(name = "Courier Prime", family = "Courier Prime") 
library(showtext)
showtext_auto()

boot_long <- boot_results %>%
  mutate(exon_bin = factor(exon_bin,
                           levels = c("1–10", "11–50", "51+"))) %>%
  unnest(boot_skews)

p <- ggplot(boot_results,
            aes(x = exon_bin, y = skew_estimate)) +
  
  # jittered bootstraps
  geom_jitter(data = boot_long,
              aes(fill = exon_bin, y = boot_skews),
              position = position_jitter(width = 0.15, height = 0),
              shape = 21,
              color = "gray30", 
              size = 2,
              alpha = 0.05,
              stroke = 0.8) +

  # polynomial regression (2nd degree)
  geom_smooth(data = boot_long,
              aes(x = as.numeric(exon_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x, 2),
              se = FALSE,
              linetype = "dashed",
              color = "grey40",    # grey line
              size = 1.5) +        # thicker

  # main points
  geom_point(aes(fill = exon_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +

  scale_fill_manual(values = c(
    "1–10"  = "#d1cbe5",
    "11–50" = "#9671bd",
    "51+"   = "#6a408d"
  ), name = "Intron Bin",
     guide = guide_legend(override.aes = list(shape = 21, 
                                             alpha = 1,
                                             size = 4,
                                             color = "gray30"))) +
            

  # significance aesthetics
  scale_color_manual(values = c(`TRUE`  = "#378d94",
                                `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +

  # densify grid on y-axis
  scale_y_continuous(
    breaks = pretty_breaks(n = 5),         # fewer major
    minor_breaks = waiver(),               # you can specify seq(min, max, length.out) here
    expand = expansion(add = 0.1)
  ) +

  # densify grid on x-axis
  scale_x_discrete(expand = expansion(add = 0.5)) +

  # labels
  labs(
    title = "Bootstrapped Skewness of FMN2 KO Splicing",
    x     = "Number of introns per gene",
    y     = "Skewness of ΔPSI Distribution"
  ) +

  # theme tweaks
  # theme tweaks
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",

    # Remove grid lines, but keep the square
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),

    # add a border around the panel
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),

    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10),
  ) +

  # Add a grey line at y = 0
  geom_hline(yintercept = 0, color = "grey50", linetype = "solid", size = 0.5)

print(p)


ggsave("fmn2_intron.svg",
       width  = 6,
       height = 6)

```



# PCA Plot { .tabset}


## Spire

```{r pca calculation spire}
# Subset and scale data
pca_spire <- filterEvents(spire_events, N=10)$PSI[, c("EVENT",spire_events$Samples)] %>%
  na.omit()

rownames(pca_spire)<- pca_spire$EVENT
pca_spire<-t(pca_spire[,-1])


pca_result_spire <- prcomp(pca_spire)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result_spire$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-metadata_spire$condition
```

```{r pca plotting spire}
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition))) +
  geom_point(size = 6, alpha = 0.9) +
  labs(
    title = "<b style='font-size:18px;'>PCA of Samples (PSI Data)</b>",
    x = paste("PC1 (", round(100 * summary(pca_result_spire)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result_spire)$importance[2, 2], 1), "%)", sep = ""),
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    plot.title = element_markdown(),
    plot.title.position = "plot",
    axis.title = element_text(size = 14, margin = margin(t = 10)),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  scale_color_paletteer_d("MetBrewer::Hokusai3") +
  coord_fixed()
ggsave("final_plots/pca_spire.svg", pca_plot, width = 5, height = 5, dpi = 300)


pca_plot

```


## FMN2

```{r pca calculation fmndko}
# Subset and scale data
pca_fmndko <- filterEvents(fmndko_events, N=10)$PSI[, c("EVENT",fmndko_events$Samples)] %>%
  na.omit()

rownames(pca_fmndko)<- pca_fmndko$EVENT
pca_fmndko<-t(pca_fmndko[,-1])


pca_result_fmndko <- prcomp(pca_fmndko)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result_fmndko$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-metadata_fmn2dko$condition
```

```{r pca plotting fmndko}
# Create PCA plot
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition), )) +
  geom_point(size = 6) +
  labs(
    title = "<b style='font-size:18px;'>PCA of Samples (PSI Data)</b>",
    x = paste("PC1 (", round(100 * summary(pca_result_fmndko)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result_fmndko)$importance[2, 2], 1), "%)", sep = ""),
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal(base_family = "roboto") +
  theme(
    plot.title = element_markdown(),
    plot.title.position = "plot",
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_blank()
  ) +
  scale_colour_paletteer_d("MetBrewer::Hokusai3") +
  coord_fixed()

pca_plot

```




# Exon Lists

```{r aux_featuregroup}
# Extract unique groups and sample IDs

# fmn2dko

metadata_fmn2dko<-data.frame(samples=c("SRR6026682_SRR6026683_SRR6026684_merged","SRR6026685_SRR6026686_SRR6026687_merged","SRR6026688_SRR6026689_SRR6026690_merged","SRR6026691_SRR6026692_SRR6026693_merged"),condition=c("control","control","fmndko","fmndko"))
groups_fmndko <- unique(metadata_fmn2dko[, "condition"])
samples_fmndko <- metadata_fmn2dko$samples

# spiredko

groups_spire <- unique(metadata_spire[, "condition"])
samples_spire <- metadata_spire$samples


random_colors=c("#D8D97AFF", "#95C36EFF", "#74C8C3FF", "#5A97C1FF", "#295384FF", "#0A2E57FF")


# Create group list with metadata
groupList_fmndko <- lapply(1:length(groups_fmndko), function(i) {
  list(
    name = groups_fmndko[i],
    samples = samples_fmndko[metadata_fmn2dko[, "condition"] == groups_fmndko[i]],
    color = random_colors[i]
  )
})
names(groupList_fmndko) <- groups_fmndko

# Create group list with metadata
groupList_spire <- lapply(1:length(groups_spire), function(i) {
  list(
    name = groups_spire[i],
    samples = samples_spire[metadata_spire[, "condition"] == groups_spire[i]],
    color = random_colors[i]
  )
})
names(groupList_spire) <- groups_spire

```

```{r groups_auxiliary}
# Define groups

groupA_fmndko<-"control"
groupB_fmndko<-"fmndko"

groupA_spire<-"control"
groupB_spire<-"spiredko"


samplesA_fmndko <- groupList_fmndko[[groupA_fmndko]]$samples
samplesB_fmndko <- groupList_fmndko[[groupB_fmndko]]$samples
colsGroupA_fmndko <- convertCols(fmndko_exons$PSI, samplesA_fmndko)
colsGroupB_fmndko <- convertCols(fmndko_exons$PSI, samplesB_fmndko)

samplesA_spire <- groupList_spire[[groupA_spire]]$samples
samplesB_spire <- groupList_spire[[groupB_spire]]$samples
colsGroupA_spire <- convertCols(spire_exons$PSI, samplesA_spire)
colsGroupB_spire <- convertCols(spire_exons$PSI, samplesB_spire)


set.seed(42) #Setting seed for downstream simulations of the beta distribution
```

## Calculations

```{r pdiff calculation exons}

# Prepare table for fmn2dko
fmndko_pdiff_exons <- prepareTableVolcanoFDR(
  psitable = fmndko_exons$PSI,
  qualtable = fmndko_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_fmndko,
  colsB = colsGroupB_fmndko,
  labA = groupA_fmndko,
  labB = groupB_fmndko,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for spire
spire_pdiff_exons <- prepareTableVolcanoFDR(
  psitable = spire_exons$PSI,
  qualtable = spire_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_spire,
  colsB = colsGroupB_spire,
  labA = groupA_spire,
  labB = groupB_spire,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)


differential_spire_exons<-na.omit(spire_pdiff_exons[spire_pdiff_exons$FDR <= 0.05 & abs(spire_pdiff_exons$deltapsi) >= 0.1,])
differential_fmndko_exons<-na.omit(fmndko_pdiff_exons[fmndko_pdiff_exons$FDR <= 0.05 & abs(fmndko_pdiff_exons$deltapsi) >= 0.1,])

shared_exons<-differential_spire_exons$EVENT[differential_spire_exons$EVENT %in% differential_fmndko_exons$EVENT]

write.csv(fmndko_pdiff_exons,"fmndko_pdiff_exons.csv")
write.csv(spire_pdiff_exons,"spire_pdiff_exons.csv")
```




## Volcano Plots { .tabset}


### FMN2

```{r fmndko fdr volcano exons}

library(ggrepel)
fmndko_pdiff_exons<-na.omit(fmndko_pdiff_exons)
# Add a Shared column based on the shared_exons
fmndko_pdiff_exons$Shared <- ifelse(fmndko_pdiff_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
fmndko_pdiff_exons$Significant <- ifelse(
  fmndko_pdiff_exons$FDR <=0.05 & fmndko_pdiff_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    fmndko_pdiff_exons$FDR <=0.05 & fmndko_pdiff_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
fmndko_pdiff_exons$negLogpvalue <- -log10(fmndko_pdiff_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
fmndko_pdiff_exons <- fmndko_pdiff_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(fmndko_pdiff_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(fmndko_pdiff_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(fmndko_pdiff_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of FMN2 Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "sans") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("final_plots/volcano_fmndko_exons.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("final_plots/volcano_fmndko_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72)


volcano_plot
```

### Spire

```{r spire fdr volcano exons}
spire_pdiff_exons<-na.omit(spire_pdiff_exons)
# Add a Shared column based on the shared_exons
spire_pdiff_exons$Shared <- ifelse(spire_pdiff_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
spire_pdiff_exons$Significant <- ifelse(
  spire_pdiff_exons$FDR <=0.05 & spire_pdiff_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    spire_pdiff_exons$FDR <=0.05 & spire_pdiff_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
spire_pdiff_exons$negLogpvalue <- -log10(spire_pdiff_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
spire_pdiff_exons <- spire_pdiff_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(spire_pdiff_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(spire_pdiff_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(spire_pdiff_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spire Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("final_plots/volcano_spire_exons.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("final_plots/volcano_spire_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot


```


## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition. 



### FMN2

```{r fmndko combination table exons}
# Render DataTable with enhancements
datatable(
  differential_fmndko_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### Spire


```{r spire combination table exons}
# Render DataTable with enhancements
datatable(
  differential_spire_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```



# Intron Lists

## Calculations

```{r pdiff calculation introns}


# Prepare table for Tao
fmndko_pdiff_introns <- prepareTableVolcanoFDR(
  psitable = fmndko_introns$PSI,
  qualtable = fmndko_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_fmndko,
  colsB = colsGroupB_fmndko,
  labA = groupA_fmndko,
  labB = groupB_fmndko,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for spire
spire_pdiff_introns <- prepareTableVolcanoFDR(
  psitable = spire_introns$PSI,
  qualtable = spire_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_spire,
  colsB = colsGroupB_spire,
  labA = groupA_spire,
  labB = groupB_spire,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

differential_spire_introns<-na.omit(spire_pdiff_introns[spire_pdiff_introns$FDR <=0.05 & abs(spire_pdiff_introns$deltapsi)>=0.1,])
differential_fmndko_introns<-na.omit(fmndko_pdiff_introns[fmndko_pdiff_introns$FDR <=0.05 & abs(fmndko_pdiff_introns$deltapsi)>=0.1,])



shared_introns<-differential_spire_introns$EVENT[differential_spire_introns$EVENT %in% differential_fmndko_introns$EVENT]

write.csv(fmndko_pdiff_introns,"fmndko_pdiff_introns.csv")
write.csv(spire_pdiff_introns,"spire_pdiff_introns.csv")

```



## Volcano Plots { .tabset}


### FMN2

```{r fmndko volcano introns}
fmndko_pdiff_introns<-na.omit(fmndko_pdiff_introns)
# Add a Shared column based on the shared_exons
fmndko_pdiff_introns$Shared <- ifelse(fmndko_pdiff_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
fmndko_pdiff_introns$Significant <- ifelse(
  fmndko_pdiff_introns$FDR <=0.05 & fmndko_pdiff_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    fmndko_pdiff_introns$FDR <=0.05 & fmndko_pdiff_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
fmndko_pdiff_introns$negLogpvalue <- -log10(fmndko_pdiff_introns$FDR)


# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
fmndko_pdiff_introns <- fmndko_pdiff_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(fmndko_pdiff_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(fmndko_pdiff_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(fmndko_pdiff_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of FMN2 Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_fmndko_introns.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_fmndko_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### Spire

```{r spire volcano introns}
spire_pdiff_introns<-na.omit(spire_pdiff_introns)
spire_pdiff_introns$Shared <- ifelse(spire_pdiff_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
spire_pdiff_introns$Significant <- ifelse(
  spire_pdiff_introns$FDR <=0.05 & spire_pdiff_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    spire_pdiff_introns$FDR <=0.05 & spire_pdiff_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
spire_pdiff_introns$negLogpvalue <- -log10(spire_pdiff_introns$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
spire_pdiff_introns <- spire_pdiff_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(spire_pdiff_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(spire_pdiff_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(spire_pdiff_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spire Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_spire_introns.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_spire_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition. 

### FMN2



```{r fmndko combination table introns}
# Render DataTable with enhancements
datatable(
  differential_fmndko_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### Spire


```{r spire combination table introns}
# Render DataTable with enhancements
datatable(
  differential_spire_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```


# Alternative 5´ & 3´

## Calculations

```{r pdiff calculation alt}

# Prepare table for Tao
fmndko_pdiff_alt <- prepareTableVolcanoFDR(
  psitable = fmndko_alt$PSI,
  qualtable = fmndko_alt$Qual,
  npoints = 500,
  colsA = colsGroupA_fmndko,
  colsB = colsGroupB_fmndko,
  labA = groupA_fmndko,
  labB = groupB_fmndko,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for spire
spire_pdiff_alt <- prepareTableVolcanoFDR(
  psitable = spire_alt$PSI,
  qualtable = spire_alt$Qual,
  npoints = 500,
  colsA = colsGroupA_spire,
  colsB = colsGroupB_spire,
  labA = groupA_spire,
  labB = groupB_spire,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

differential_spire_alt<-na.omit(spire_pdiff_alt[spire_pdiff_alt$FDR <=0.05 & abs(spire_pdiff_alt$deltapsi)>=0.1 ,])
differential_fmndko_alt<-na.omit(fmndko_pdiff_alt[fmndko_pdiff_alt$FDR <=0.05 & abs(fmndko_pdiff_alt$deltapsi)>=0.1 ,])

shared_alt<-differential_spire_alt$EVENT[differential_spire_alt$EVENT %in% differential_fmndko_alt$EVENT]

write.csv(fmndko_pdiff_alt,"fmndko_pdiff_alt.csv")
write.csv(spire_pdiff_alt,"spire_pdiff_alt.csv")
```




## Volcano Plots { .tabset}


### FMN2

```{r fmndko  volcano alt}
fmndko_pdiff_alt<-na.omit(fmndko_pdiff_alt)
fmndko_pdiff_alt$Shared <- ifelse(fmndko_pdiff_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
fmndko_pdiff_alt$Significant <- ifelse(
  fmndko_pdiff_alt$FDR <=0.05 & fmndko_pdiff_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    fmndko_pdiff_alt$FDR <=0.05 & fmndko_pdiff_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
fmndko_pdiff_alt$negLogpvalue <- -log10(fmndko_pdiff_alt$FDR)
# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
fmndko_pdiff_alt <- fmndko_pdiff_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(fmndko_pdiff_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(fmndko_pdiff_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(fmndko_pdiff_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of FMN2 Alt 5´ 3´",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_fmndko_alt.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_fmndko_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### Spire

```{r spire fdr volcano alt}
spire_pdiff_alt<-na.omit(spire_pdiff_alt)
spire_pdiff_alt$Shared <- ifelse(spire_pdiff_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
spire_pdiff_alt$Significant <- ifelse(
  spire_pdiff_alt$FDR <=0.05 & spire_pdiff_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    spire_pdiff_alt$FDR <=0.05 & spire_pdiff_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
spire_pdiff_alt$negLogpvalue <- -log10(spire_pdiff_alt$FDR)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
spire_pdiff_alt <- spire_pdiff_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(spire_pdiff_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(spire_pdiff_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(spire_pdiff_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spire Alt 5´ 3´",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )



# Save as SVG with dimensions 606 x 396
ggsave("volcano_spire_alt.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_spire_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition. 


### FMN2


```{r fmndko combination table alt}
# Render DataTable with enhancements
datatable(
  differential_fmndko_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### Spire



```{r spire combination table alt}
# Render DataTable with enhancements
datatable(
  differential_spire_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

# All Event Types Volcano Plots { .tabset}


## FMN2

```{r fmndko all volcano }

mega_volcano<-rbind(fmndko_pdiff_alt,fmndko_pdiff_exons,fmndko_pdiff_introns)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of FMN2 All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_fmndko_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72)
ggsave("volcano_fmndko_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)

volcano_plot
```

## Spire

```{r spire fdr volcano all}
mega_volcano<-rbind(spire_pdiff_alt,spire_pdiff_exons,spire_pdiff_introns)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spire All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_spire_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72)
ggsave("volcano_spire_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)

volcano_plot
```


# Basic Stats on Found Events

## Events-level stats

```{r basic stats}
# Define study-specific data
fmndko_exons <- data.frame(EVENT = differential_fmndko_exons$EVENT, Type = "Exons", Study = "FMN2")
fmndko_introns <- data.frame(EVENT = differential_fmndko_introns$EVENT, Type = "Introns", Study = "FMN2")
fmndko_alt <- data.frame(EVENT = differential_fmndko_alt$EVENT, Type = "Alt", Study = "FMN2")

spire_exons <- data.frame(EVENT = differential_spire_exons$EVENT, Type = "Exons", Study = "Spire")
spire_introns <- data.frame(EVENT = differential_spire_introns$EVENT, Type = "Introns", Study = "Spire")
spire_alt <- data.frame(EVENT = differential_spire_alt$EVENT, Type = "Alt", Study = "Spire")
# Define subsets for each event type
event_list_exons <- list(
  FMN2_Exons  = unique(fmndko_exons$EVENT),
  Spire_Exons = unique(spire_exons$EVENT)
)

event_list_introns <- list(
  FMN2_Introns  = unique(fmndko_introns$EVENT),
  Spire_Introns = unique(spire_introns$EVENT)
)

event_list_alt <- list(
  FMN2_Alt  = unique(fmndko_alt$EVENT),
  Spire_Alt = unique(spire_alt$EVENT)
)

# Define colors
color_exons <- c("#4E79A7", "#4E79A7")  # Blue for exons
color_introns <- c("#F28E2B", "#F28E2B")  # Orange for introns
color_alt <- c("#E15759", "#E15759")  # Red for alternative splicing events

# Generate UpSet plots
p_exons<-upset(fromList(event_list_exons),
                 nsets = 2,
                 order.by = "freq",
                 sets.bar.color = color_exons,
                 mainbar.y.label = "Exon Overlapping Events",
                 sets.x.label = "Number of Exon Events",
                 text.scale = 2)

p_introns <- upset(fromList(event_list_introns),
                   nsets = 2,
                   order.by = "freq",
                   sets.bar.color = color_introns,
                   mainbar.y.label = "Intron Overlapping Events",
                   sets.x.label = "Number of Intron Events",
                   text.scale = 2)

p_alt <- upset(fromList(event_list_alt),
               nsets = 2,
               order.by = "freq",
               sets.bar.color = color_alt,
               mainbar.y.label = "Alt Overlapping Events",
               sets.x.label = "Number of Alt Events",
               text.scale = 2)


p_exons
p_introns
p_alt
```

## Gene-level stats

```{r, basic gene stats}

gene_list <- list(
  FMN2  = unique(c(differential_fmndko_exons$GENE,differential_fmndko_introns$GENE,differential_fmndko_alt$GENE)),
  Spire = unique(c(differential_spire_exons$GENE,differential_spire_introns$GENE,differential_spire_alt$GENE))
)


shared_genes<-intersect(gene_list$FMN2,gene_list$Spire)
# Generate UpSet plots
p_genes<-upset(fromList(gene_list),
                 nsets = 2,
                 order.by = "freq",
                 sets.bar.color = "#0099cf",
                 mainbar.y.label = "Overlapping Genes",
                 sets.x.label = "Number of Genes",
                 text.scale = 2)

p_genes
```


# Enrichment Analysis with EnrichR of All Events { .tabset}

The following ontology analysis uses all significant events regardless of type. No background gene list was used for the following enrichment analysis. For a background-aware ontology analysis, check the *Metascape* analysis.

## FMN2 { .tabset}

```{r fmndko enrichr}
enrichdata<-enrichr(unique(c(differential_fmndko_exons$GENE, differential_fmndko_introns$GENE, differential_fmndko_alt$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


### GO Biological Process

```{r fmndko bioprocess, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Cellular Component

```{r fmndko cellcomponent, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Molecular Function

```{r fmndko molfunction, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])

rna_fmndko_genes <- unlist(strsplit(
  enrichdata[[3]]$Genes[grepl("GO:0003723", enrichdata[[3]]$Term)], 
  split = ";"
))


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

## Spire { .tabset}

```{r spire enrichr}
enrichdata<-enrichr(unique(c(differential_spire_exons$GENE, differential_spire_introns$GENE, differential_spire_alt$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))


```

### GO Biological Process

```{r spire bioprocess, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])
datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Cellular Component

```{r spire cellcomponent, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])
datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Molecular Function

```{r spire molfunction, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])
datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


## Ontology of Shared Genes { .tabset}

```{r shared enrichr}
enrichdata<-enrichr(unique(shared_genes), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


### GO Biological Process

```{r shared bioprocess, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Cellular Component

```{r shared cellcomponent, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### GO Molecular Function

```{r shared molfunction, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])

rna_fmndko_genes <- unlist(strsplit(
  enrichdata[[3]]$Genes[grepl("GO:0003723", enrichdata[[3]]$Term)], 
  split = ";"
))


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


# Enrichment Analysis with EnrichR of Specific Types { .tabset}


## FMN2 { .tabset}

### Exons { .tabset}

```{r fmndko enrichr ex}
enrichdata<-enrichr(unique(c(differential_fmndko_exons$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


#### GO Biological Process

```{r fmndko bioprocess ex, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r fmndko cellcomponent ex, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r fmndko molfunctionn ex, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])

rna_fmndko_genes <- unlist(strsplit(
  enrichdata[[3]]$Genes[grepl("GO:0003723", enrichdata[[3]]$Term)], 
  split = ";"
))


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


### Introns { .tabset}

```{r fmndko enrichr in}
enrichdata<-enrichr(unique(c(differential_fmndko_introns$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


#### GO Biological Process

```{r fmndko bioprocess in, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r fmndko cellcomponent in, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r fmndko molfunction in, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])

rna_fmndko_genes <- unlist(strsplit(
  enrichdata[[3]]$Genes[grepl("GO:0003723", enrichdata[[3]]$Term)], 
  split = ";"
))


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


### Alternative 5´ & 3´ { .tabset}

```{r fmndko enrichr alt}
enrichdata<-enrichr(unique(c(differential_fmndko_alt$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


#### GO Biological Process

```{r fmndko bioprocess alt, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r fmndko cellcomponent alt, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r fmndko molfunction alt, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])

rna_fmndko_genes <- unlist(strsplit(
  enrichdata[[3]]$Genes[grepl("GO:0003723", enrichdata[[3]]$Term)], 
  split = ";"
))


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

## Spire { .tabset}

### Exons { .tabset}

```{r spire enrichr 2}
enrichdata<-enrichr(unique(c(differential_spire_exons$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


#### GO Biological Process

```{r spre bioprocess ex, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r spire  cellcomponent ex, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r spire  molfunction ex, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])

rna_fmndko_genes <- unlist(strsplit(
  enrichdata[[3]]$Genes[grepl("GO:0003723", enrichdata[[3]]$Term)], 
  split = ";"
))


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


### Introns { .tabset}

```{r spire enrichr int}
enrichdata<-enrichr(unique(c(differential_spire_introns$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


#### GO Biological Process

```{r spire bioprocess int, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r spire cellcomponent int, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r spire molfunction int, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])

rna_fmndko_genes <- unlist(strsplit(
  enrichdata[[3]]$Genes[grepl("GO:0003723", enrichdata[[3]]$Term)], 
  split = ";"
))


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


### Alternative 5´ & 3´ { .tabset}

```{r spire enrichr alt}
enrichdata<-enrichr(unique(c(differential_spire_alt$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


#### GO Biological Process

```{r spire bioprocess alt, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r spire cellcomponent alt, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r spire molfunction alt, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])

rna_fmndko_genes <- unlist(strsplit(
  enrichdata[[3]]$Genes[grepl("GO:0003723", enrichdata[[3]]$Term)], 
  split = ";"
))


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


# Gene-centric Analysis { .tabset}

The following analysis identifies the number of significant events a given gene has. This number of *hits* serves as a proxy of how heavily influenced by splicing a given gene has been. The table shows how many genes classified by the number of significant events I have found, alongside the proportion of ORF disruption for each group. The plot then shows the list of genes, with at least 3 *hits*, in the x-axis, their average |dPSI| in the y-axis, and the shape of the points shows whether that given event is ORF-disrupted.

## FMN2

```{r gene-centric plot fmn2 prep}
# Set seed for reproducibility
set.seed(44)

# -------------------------------
# 0. Read protein impact data and combine your events
# -------------------------------
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, 
                             fill = TRUE, quote = "")

# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_fmndko_exons,
  introns = differential_fmndko_introns,
  alt = differential_fmndko_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF-shifted genes" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r fmn2 gene-centric plot, fig.width=24, fig.height=10}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.6) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in FMN2",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("final_plots/fmn2_splicing_events_plot.svg", plot = p2, width = 24, height = 10)

# Display the plot
print(p2)
```


## Spire

```{r gene-centric plot spire prep}
# Set seed for reproducibility
set.seed(44)



# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_spire_exons,
  introns = differential_spire_introns,
  alt = differential_spire_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF-shifted genes" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r spire gene-centric plot, fig.width=30, fig.height=12}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.7) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in Spire",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("spire_splicing_events_plot.svg", plot = p2, width = 30, height = 12, dpi = 300)

# Display the plot
print(p2)
```



# Splicing Dynamics Heatmap Spire


```{r heatmap pre-prep, results='hide', fig.show='hide'}

# Extract all events
spire_all <- filterEvents(
  spire_events,
  types = c("C1", "C2", "C3", "S", "MIC", "IR","Alt3","Alt5"),
  N = 10
)
```

```{r heatmap prep, results='hide', fig.show='hide'}
# Load required libraries
library(ComplexHeatmap)
library(circlize)
library(viridis)    # for viridis palette
library(dplyr)
library(grid)
library(tidyr)      # if needed for replace_na
library(enrichR)    # assuming enrichr() is from enrichR package

set.seed(44)

# --------------------------
# Data Preparation
# --------------------------
# Get unique splicing events (remove NA events) and convert selected PSI columns to matrix
spire_unique <- spire_all$PSI %>% distinct(EVENT, .keep_all = TRUE)
spire_unique <- spire_unique[!is.na(spire_unique$EVENT), ]
rownames(spire_unique) <- spire_unique$EVENT
spire_unique <- as.matrix(spire_unique[,7:12])

# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_spire_exons[abs(differential_spire_exons$deltapsi) >= 0.1, "EVENT"],
  differential_spire_introns[abs(differential_spire_introns$deltapsi) >= 0.1, "EVENT"]
))
spire_unique <- spire_unique[rownames(spire_unique) %in% filtered_events, ]

# Create a dendrogram for the columns (using hierarchical clustering on the transposed data)
col_dend <- hclust(dist(t(spire_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2)

# Define a color function using a viridis palette.
# Here we assume the PSI values range from 0 to 100 with a midpoint at 50.
col_fun <- colorRamp2(
  c(0, 50, 100),
  viridis(3)
)

number_splices <- 8

# Create a reference table for enrichment analysis by combining events and genes
reference_table <- data.frame(
  EVENT = c(
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "EVENT"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "EVENT"],
    differential_spire_exons[abs(differential_spire_exons$deltapsi) >= 0.1, "EVENT"],
    differential_spire_introns[abs(differential_spire_introns$deltapsi) >= 0.1, "EVENT"]
  ),
  GENE = c(
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "GENE"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "GENE"],
    differential_spire_exons[abs(differential_spire_exons$deltapsi) >= 0.1, "GENE"],
    differential_spire_introns[abs(differential_spire_introns$deltapsi) >= 0.1, "GENE"]
  )
)

# --------------------------
# Initial Heatmap and Annotations
# --------------------------
# Calculate the initial heatmap to obtain cluster order
ht <- Heatmap(
  spire_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(8, "mm"),      # increased gap for white space between rows
  column_gap = unit(8, "mm"),   # increased gap for white space between columns
  rect_gp = gpar(col = "white", lwd = 0.3),
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),
    legend_direction = "vertical"
  )
)
ht <- draw(ht)
clustered_events <- row_order(ht)

# Build the left annotation: Protein impact points.
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")
events_for_impact <- rownames(spire_unique)
final_impact <- data.frame(EventID = rownames(spire_unique)) %>%  
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),
    size = unit(4, "mm"),
    axis_param = list(
      side = "top",
      at = -2:2,
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45,
      gp = gpar(fontsize = 15)
    )
  )
)

# Perform enrichment analysis for each cluster and prepare right annotation text.
text_list <- list()
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(spire_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)



```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

# --------------------------
# Final Heatmap with Annotations
# --------------------------
colnames(spire_unique) <- c("Control 1", "Control 2", "Control 3", "Spire KO 1", "Spire KO 2", "Spire KO 3")

ht <- Heatmap(
  spire_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Spire Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 0,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  left_annotation = left_annotation,    # Protein impact annotation on left
  right_annotation = right_annotation,  # Enrichment annotation on right
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "black"),
  show_row_names = FALSE,
  row_gap = unit(5, "mm"),      # Increased white space between rows
  column_gap = unit(5,"mm"),   # Increased white space between columns
  rect_gp = gpar(col = "white", lwd = 0.1),  # Adjusted white grid visibility
  
)
ht <- draw(ht)

# Decorate the right annotation slices with the enrichment text.
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}
```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- spire_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

heatmap_dataframe_spire<-heatmap_dataframe
# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```


### Same Heatmap but averaging PSI values from same condition

```{r heatmap_plot short spire, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

spire_unique_short <- cbind(
  rowMeans(spire_unique[, 1:3]),
  rowMeans(spire_unique[, 4:6])
)

# Convert to matrix and print result
colnames(spire_unique_short) <- c("Control", "SpireKO")

spire_unique_short <- spire_unique_short[row_order,]

ht <- Heatmap(
  spire_unique_short,
  name = "PSI",
  col = col_fun,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:3),
  cluster_rows = FALSE,   # <-- This disables row clustering
  cluster_columns = FALSE, # Optionally disable column clustering if desired
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"),      # Adjust the gap size between rows
  left_annotation = left_annotation[row_order],   # Add the points on the left
  right_annotation = right_annotation[row_order],
  column_gap = unit(4, "mm"),   # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend vertically
  )
)

# Draw the heatmap
ht <- draw(ht)

# Draw the heatmap




```


### Protein Impact on Splicing Events

I extracted the different subsets of significant splicing events and grouped them by the protein impact. The plot depicts that the protein impact does not alter the splicing tendency: some events (grey dots in the plot) will be included or excluded, but the population means of the WT and KO remain equal.

```{r protein impact psi spire, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}

library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)      # For pairwise comparisons and p-value adjustment
library(ggpubr)       # For stat_pvalue_manual if needed

original_columns <- colnames(spire_unique)
# Prepare the data frame
spire_df <- as.data.frame(spire_unique) %>% 
  rownames_to_column("EVENT") %>% 
  pivot_longer(
    cols = -EVENT,
    names_to = "sample",
    values_to = "value"
  ) 

# Modify dose based on sample name
spire_df <- spire_df %>%
  mutate(
    variable_order = match(sample, original_columns),
    group = ceiling(variable_order / 3),
    condition = case_when(
      str_detect(sample, "KO") ~ "KO",
      str_detect(sample, "Cont") ~ "Control",
      TRUE ~ NA_character_
    ),
    condition = factor(condition, levels = c("Control", "KO"))  # Ensure correct order
  ) %>%
  select(-variable_order, -group)

# Assign the protein impact based on matching EventID.
spire_df$protein_impact <- final_impact_string$ONTO[match(spire_df$EVENT, final_impact_string$EventID)]

# Cluster the protein_impact values into desired groups
spire_df <- spire_df %>%
  mutate(
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disruption upon inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disruption upon exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ "Unknown"
    )
  ) %>%
  arrange(EVENT, sample, condition)

# Function to calculate bootstrap confidence intervals
bootstrap_ci <- function(values, n_bootstrap = 1000, conf_level = 0.95) {
  boot_samples <- replicate(n_bootstrap, mean(sample(values, replace = TRUE)))
  quantile(boot_samples, probs = c((1 - conf_level) / 2, 1 - (1 - conf_level) / 2), na.rm=TRUE)
}

# Compute summary statistics with bootstrapped confidence intervals
summary_df <- spire_df %>%
  group_by(condition, protein_impact) %>%
  summarise(
    mean_value = mean(value),
    sd_value = sd(value),
    n = n(),
    ci_lower = bootstrap_ci(value)[1],
    ci_upper = bootstrap_ci(value)[2],
    .groups = "drop"
  )


# Set the upper y-axis limit dynamically
max_y <- max(spire_df$value, na.rm = TRUE) * 1.1  

# Plot with refined settings
impact_psi_plot<-ggplot(summary_df, 
       aes(x = condition, y = mean_value, group = protein_impact, color = protein_impact, fill = protein_impact)) +
  geom_point(data = spire_df, aes(x = condition, y = value), color = "grey70", alpha = 0.4, size = 1) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +
  


  # Facet by protein impact
  facet_wrap(~ protein_impact) +

  # Adjust x and y axes
  scale_y_continuous(limits = c(0, max_y), expand = expansion(mult = c(0.05, 0.05))) +

  # Clean and minimal theme
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major = element_line(color = "grey85", size = 0.3),
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 12),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(size = 10)
  ) +
  
  # Labels
  labs(x = "Condition", 
       y = "Mean PSI", 
       color = "Protein Impact", 
       fill = "Protein Impact")
ggsave("final_plots/protein_impact_plot_spire.svg", impact_psi_plot, width = 12, height = 8)

impact_psi_plot
```



# Splicing Dynamics Heatmap FMN2


```{r heatmap pre-prep fmn2, results='hide', fig.show='hide'}

# Extract all events
fmndko_all<- filterEvents(
  fmndko_events,
  types = c("C1", "C2", "C3", "S", "MIC", "IR","Alt3","Alt5"),
  N = 10
)
```

```{r heatmap prep fmn2, results='hide', fig.show='hide'}


set.seed(44)

# --------------------------
# Data Preparation
# --------------------------
# Get unique splicing events (remove NA events) and convert selected PSI columns to matrix
fmndko_unique <- fmndko_all$PSI %>% distinct(EVENT, .keep_all = TRUE)
fmndko_unique <- fmndko_unique[!is.na(fmndko_unique$EVENT), ]
rownames(fmndko_unique) <- fmndko_unique$EVENT
fmndko_unique <- as.matrix(fmndko_unique[,7:10])

# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "EVENT"],
  differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "EVENT"]
))
fmndko_unique <- fmndko_unique[rownames(fmndko_unique) %in% filtered_events, ]

# Create a dendrogram for the columns (using hierarchical clustering on the transposed data)
col_dend <- hclust(dist(t(fmndko_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2)

# Define a color function using a viridis palette.
# Here we assume the PSI values range from 0 to 100 with a midpoint at 50.
col_fun <- colorRamp2(
  c(0, 50, 100),
  viridis(3)
)

number_splices <- 6

# Create a reference table for enrichment analysis by combining events and genes
reference_table <- data.frame(
  EVENT = c(
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "EVENT"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "EVENT"],
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "EVENT"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "EVENT"]
  ),
  GENE = c(
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "GENE"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "GENE"],
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "GENE"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "GENE"]
  )
)

# --------------------------
# Initial Heatmap and Annotations
# --------------------------
# Calculate the initial heatmap to obtain cluster order
ht <- Heatmap(
  fmndko_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:4,
  row_km = number_splices,
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(8, "mm"),      # increased gap for white space between rows
  column_gap = unit(8, "mm"),   # increased gap for white space between columns
  rect_gp = gpar(col = "white", lwd = 0.3),
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),
    legend_direction = "vertical"
  )
)
ht <- draw(ht)
clustered_events <- row_order(ht)

# Build the left annotation: Protein impact points.
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")
events_for_impact <- rownames(fmndko_unique)
final_impact <- data.frame(EventID = rownames(fmndko_unique)) %>%  
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),
    size = unit(4, "mm"),
    axis_param = list(
      side = "top",
      at = -2:2,
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45,
      gp = gpar(fontsize = 15)
    )
  )
)

# Perform enrichment analysis for each cluster and prepare right annotation text.
text_list <- list()
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(fmndko_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)



```


### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot fmn2, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

# --------------------------
# Final Heatmap with Annotations
# --------------------------
colnames(fmndko_unique) <- c("Control 1", "Control 2", "FMN2 KO 1", "FMN2 KO 2")

ht <- Heatmap(
  fmndko_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes FMN2 Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 0,
  column_dend_reorder = 1:4,
  row_km = number_splices,
  left_annotation = left_annotation,    # Protein impact annotation on left
  right_annotation = right_annotation,  # Enrichment annotation on right
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "black"),
  show_row_names = FALSE,
  row_gap = unit(5, "mm"),      # Increased white space between rows
  column_gap = unit(5,"mm"),   # Increased white space between columns
  rect_gp = gpar(col = "white", lwd = 0.1),  # Adjusted white grid visibility
  
)
ht <- draw(ht)

# Decorate the right annotation slices with the enrichment text.
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}
```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap fmn2 final}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- fmndko_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

heatmap_dataframe_spire<-heatmap_dataframe
# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```


### Same Heatmap but averaging PSI values from same condition

```{r heatmap_plot short, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

fmndko_unique_short <- cbind(
  rowMeans(fmndko_unique[, 1:2]),
  rowMeans(fmndko_unique[, 3:4])
)

# Convert to matrix and print result
colnames(fmndko_unique_short) <- c("Control", "FMN2KO")

fmndko_unique_short <- fmndko_unique_short[row_order,]

ht <- Heatmap(
  fmndko_unique_short,
  name = "PSI",
  col = col_fun,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:3),
  cluster_rows = FALSE,   # <-- This disables row clustering
  cluster_columns = FALSE, # Optionally disable column clustering if desired
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"),      # Adjust the gap size between rows
  left_annotation = left_annotation[row_order],   # Add the points on the left
  right_annotation = right_annotation[row_order],
  column_gap = unit(4, "mm"),   # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend vertically
  )
)

# Draw the heatmap
ht <- draw(ht)



```

### Protein Impact on Splicing Events

I extracted the different subsets of significant splicing events and grouped them by the protein impact. The plot depicts events ORF-disrupted upon inclusion being generally excluded (the proteins gain function in the KO samples), and events ORF-disrupted upon exclusion being included (the proteins gain function in the KO samples too).

```{r protein impact psi fmn2}

library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)      # For pairwise comparisons and p-value adjustment
library(ggpubr)       # For stat_pvalue_manual if needed

original_columns <- colnames(fmndko_unique)
# Prepare the data frame
fmn_df <- as.data.frame(fmndko_unique) %>% 
  rownames_to_column("EVENT") %>% 
  pivot_longer(
    cols = -EVENT,
    names_to = "sample",
    values_to = "value"
  ) 

# Modify dose based on sample name
fmn_df <- fmn_df %>%
  mutate(
    variable_order = match(sample, original_columns),
    group = ceiling(variable_order / 3),
    condition = case_when(
      str_detect(sample, "Control") ~ "Control",
      str_detect(sample, "KO") ~ "KO",
      TRUE ~ NA_character_
    ),
    condition = factor(condition, levels = c("Control", "KO"))  # Ensure correct order
  ) %>%
  select(-variable_order, -group)

# Assign the protein impact based on matching EventID.
fmn_df$protein_impact <- final_impact_string$ONTO[match(fmn_df$EVENT, final_impact_string$EventID)]

# Cluster the protein_impact values into desired groups
fmn_df <- fmn_df %>%
  mutate(
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disruption upon inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disruption upon exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ "Unknown"
    )
  ) %>%
  arrange(EVENT, sample, condition)

# Function to calculate bootstrap confidence intervals
bootstrap_ci <- function(values, n_bootstrap = 1000, conf_level = 0.95) {
  boot_samples <- replicate(n_bootstrap, mean(sample(values, replace = TRUE)))
  quantile(boot_samples, probs = c((1 - conf_level) / 2, 1 - (1 - conf_level) / 2))
}

# Perform pairwise paired t-tests within each protein_impact group
stat_test <- fmn_df %>%
  group_by(protein_impact) %>%
  pairwise_t_test(
    value ~ condition,
    paired = TRUE,
    p.adjust.method = "none"
  ) %>%
  ungroup() %>%
  filter(p.adj < 0.05) %>%
  mutate(signif = case_when(
    p.adj < 0.001 ~ "***",
    p.adj < 0.01  ~ "**",
    p.adj < 0.05  ~ "*"
  ))

# Compute summary statistics with bootstrapped confidence intervals
summary_df <- fmn_df %>%
  group_by(condition, protein_impact) %>%
  summarise(
    mean_value = mean(value),
    sd_value = sd(value),
    n = n(),
    ci_lower = bootstrap_ci(value)[1],
    ci_upper = bootstrap_ci(value)[2],
    .groups = "drop"
  )

# Ensure dose is a factor in stat_test
stat_test <- stat_test %>%
  mutate(
    group1 = factor(group1, levels = levels(fmn_df$condition)),
    group2 = factor(group2, levels = levels(fmn_df$condition)),
    y.position = max(fmn_df$value, na.rm = TRUE) * 1.05  # Adjusted dynamically
  )

# Set the upper y-axis limit dynamically
max_y <- max(fmn_df$value, na.rm = TRUE) * 1.1  

# Plot with refined settings
impact_psi_plot_fmn<-ggplot(summary_df, 
       aes(x = condition, y = mean_value, group = protein_impact, color = protein_impact, fill = protein_impact)) +
  geom_point(data = fmn_df, aes(x = condition, y = value), color = "grey70", alpha = 0.4, size = 1) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +
  
  # Add significance annotations
  stat_pvalue_manual(
    stat_test, 
    label = "signif",
    xmin = "group1", 
    xmax = "group2",
    y.position = "y.position",
    tip.length = 0.01,
    size = 4
  ) +

  # Facet by protein impact
  facet_wrap(~ protein_impact) +

  # Adjust x and y axes
  scale_y_continuous(limits = c(0, max_y), expand = expansion(mult = c(0.05, 0.05))) +

  # Clean and minimal theme
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major = element_line(color = "grey85", size = 0.3),
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 12),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(size = 10)
  ) +
  
  # Labels
  labs(x = "Condition", 
       y = "Mean PSI", 
       color = "Protein Impact", 
       fill = "Protein Impact")

ggsave("final_plots/protein_impact_plot_fmn2.svg", impact_psi_plot_fmn, width = 12, height = 8)
impact_psi_plot_fmn
```


# System Settings

```{r session info}
sessionInfo()
```
